Unit Under Test.

Nem magát a nyelvet teszteljük, hanem az üzleti logikát, azért nem írunk teszteket getterekre() és setterekre().
Ezeket közvetve teszteljük. 

privát metódusokat sem tesztelünk általában.

A @Befora és az @After minden @Test elõtt és után lefutnak.
Van még olyan h @BeforeClas és @AfterClass

BankAccount acc;

@Before
public void setUp(){} throws Exception {
	acc = new BankAccount(100);
}

@After
public void tearDown() throws Exception {
	//relase anything you need;
}

@Test
public void testWithdraw(){
	assertTrue(acc.withdraw(50));
	assertEquals(acc.getBalance(),50); 
}

Mikor használunk mock objecteket?
	Ha az eredetit még nem írták meg.
	Ha UI-t hívunk és interakcióra számítunk.
	Lassú, vagy nehéz felállítani.
	Külsõ erõforrás: filerendszer, adatbázis, hálózat, nyomtató.
	Nem determinisztikus viselkedés. (Valamilyen network service)
	
Fake Objects Vs. Mock Objects
	Fake is vissza tud adni eredményt, de a Mock verify-olja is az interakciót.
	
A Code Coverage csak azt méri h érintettük az adott sort, hogy maga jó adatot, az összes határértéket/küszöböt megvizsgáltuk-e azt nem jelenti.
	Code Coverage tool: Emma, eclemma, clover
	





























	