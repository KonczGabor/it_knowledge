O'Reilly Spring MVC for Java Developer kurzus alapján.

MVC: pattern, principle, architecture

Model: Az objectek a rendszerünkben

View: renders the model

Controller: performs the logic.

A spring project egy Spring MVC template alapján elkészólõ maven project

	A web.xml-ben lehet többek között a dispatcher servletet is konfigurálni (azon belül saját xml-jében (dispatcher-servlet.xml)), 
		ami a front controllerünk, ami fogadja a kéréseket és szolgáltatja a válaszokat.
		<servlet>
			<servlet-name>appServlet
			<org.springframework.servlet.DispatcherServlet>
		
				A servlet-context.xml azt mondja meg h hogyan legyen konfigurálva a dispatcher servlet.
				
			A <servlet-mapping>
				<servlet-name>dispatcher
				<url-patterm>/
				
			Azt mondja meg h milyen url címen csücsüljön a server.
				
		Az urleken keresztúl hívjuk meg a controllereket, amik ha egy jsp-tadnak vissza, akkor a servlet-context benmeghatározott
		InternalResourceViewResolver segítségével keresik meg a jsp.kiterjesztés nélküli jsp-t. (pre/suffix)
		
		
	A sima maven projektet át tudjuk alakítani spring projektté, ha jobbklikk a projekten, Configure ->Convert To Faceted Form
		Ott pipáljuk be a Dynamic Web Module-t (Version 3.1 legalább)
		
		Java Build Path/Libraries, JRE System library->remove
		Add Library -> JRE System library 
		Add Library -> Server Runtime (Pivotal tc Server)
		
		Ok(Megjelenik a WebContnent mapp, törüljük ki a Package Explorer-bõl.)
		
		Helyette készítünk egy új foldert az src main alatt webapp néven, ezt rá kell tenni a deployment route-ra.
			alt-enter => project settings
				Deployment Assempbly
					/WebContnent ->Remove
					Add -> Folder ->serc main webapp 
					
		Álljunk a projektre, jobb klikk, JavaEE Tools, Generate Deployment Descriptor Stub -> Létrejön a WEB-INF directory és abban a web.xml file


Minden Spring Application kontext (web.xml létrehoz egy Web Application kontextet) felel egy IoC konténerért. Ezek a konténerek felelnek a beaneknek létrehozásért, felparaméterezéséért és beinjektálásáért a konténerbe.

Root Application Context: (Egy másik típusa az application kontextnek a Root Application context)
	A dispatcher servelt scope-ján kívüli összes más bean konfigurálására szolgál. Azokra amik nem MVC related-ek. Data-repositryk, Security
	applicationContext.xml (Ez egy Spring bean): Ez egy új bean configuration file
		Az ebben deklarált beanek elérhetõek lesznek a Dispatcher servlet számára.
			Ha az applicationContext.xml file ban deklarálunk beaneket, azok elérhetõek lesznek az xml.configuration filjainkban a Dispatcher servlet számára.
			Fordítva nem igaz, az applicationContext nem lát bele a DispatcherServlet-be
			
			Ezt tegyük bele a web.xml.be:
				<context-param>
					<param-name>contextConfigLocation</param-name>
					<param-value>/WEB-INF/applicationContext.xml</param-value>
				</context-param>

DispatcherServlet-hez hozz kell adni két nameSpace-t (Elég ha a Namespaces fülön (Nem a Source amin alapból állunk) bepippantjuk):
	context
	mvc
		A schemaLocation-ünk így kibõvül.
		
		<mvc:annotation-driven/> -t adjuk hozzá a dispatcher-servlet -ben. //Innentõl tudjuk hazsnálni a @Controller annotációt (többek között) a .java filejainkban.
			
		
		<context:component-scan base-package="/mvc.controllers"></context:component-scan> Az ittlévõ fileokat fogja véginézni a DispatcherServlet controllerek után kutatva.

		<mvc:resources location="/resources/" mapping="/resources/**"><mvc:resources>	//Statikus resource-ok feloldására szolgál. Ez a resources mappa a webapp alatt van, ebben vannak a statikus resource-ok. (**bármilyen mélységben)

ViewResolver: egy mechanizmust biztosít arra hogya controller által visszadott logical viewName (return ben a pre és suffxek nélkül) alapján visszakapjunk egy view-t.
	A spring default internalViewResolverét a dispatcher-servlet.xml ben konfigurálhatjuk
		<bean id="viewResolver" class="org.springframework.web.servlet.view.internalViewResolver">
			<property name ="prefix" value="/WEB-INF/views/">
			<property name ="suffix" value="/WEB-INF/.sjp">
		</bean>

		
JSP		
static resource-ok(css, js) megadása, melyeket a view-ok használnak fel
<%@ taglib %prefix="spring" uri="http://www.springframework.org/tags">
<link rel="stylesheet" href="<spring:url value="/resources/css/home.css"/>" type="text/css/>"

<mvc:resources location="/resources/" mapping="/resources/**"><mvc:resources> Ezt még bele kell tenni a dispatcher-servlet.xml-be hogy mûködjön a feloldás.

Contoller: //Az ami kezeli a url-t
	@RequestMapping("/home")	//Ezen az url-en fog csücsülni a kontrollerben -handler method
	@ResponseBody				//Ezt a választ fogja majd visszaadni a kontroller
	
	
	
	A controller adja át a model-t a view nak.
	
	Reqest URL: http:localhost:8080/example/test/22
	
	@Controller@RequestMapping("/example")
	public class ExampleController {
	
	@RequestMapping("/test/{testId}") segítségével tudunk kinyerni adatokat az url-bõl.
	public String test(@PathVariable("testId") Long testId){}
	
	-----------------------------------
	
	Reqest URL: http:localhost:8080/example?action=test		//Itt nem url változó, hanem paraméter megy át.
	
	@Controller@RequestMapping("/example")
	public class ExampleController {
	
	@RequestMapping("/example")
	public String test(@RequestParam("action") String action){}	

	-----------------------------------
	
	Data Binding		Itt konkrét osztállyba mappelõdnek le az attribútumok (Example), amiket a setName() fog lekezelni.
	
	Request
	Parameters: name Kevin Boxersox
	
	@Controller
	public class ExampleController{
		@RequestMapping("/save")
		public String save(@ModelAttribute Example example){
		}
	}
	
	public class Example{
		private String name;
		
		public String getName(){
			return name;
		}
		
		public void setName(String name){
			this.name = name;
		}
	}

Controller

	Az alkalmazásunk viselkedését valósítja meg, egy url a controller által kerül kiszolgálásra, és a kontroler általában valamilyen service segítéségét kéri.
	A spring contrellereinek nincs semmiféle dependenciája J2EE specifikus osztályok felé, mint amilyen pl sevlets és nem is kell semmilyen j2EE osztályt kiterjeszteniük.
	
	Egy osztályban lévõ @RequestMapping("")-ok füzérbe állnak hierarchia mentén:
		
			@Controller
			@RequestMapping("/project")
			public class ProjectController {
			
				@RequestMapping("/add")
				public String addProject(){
					return "project_add"
				}
			}
			
			--------------------------> Megegyezik
			
			@Controller
			@RequestMapping("/project/add")
			public class ProjectController {
			
				public String addProject(){
					return "project_add"
				}
			}
			
	Ugyanarra az url-re mappelõdhet két metódus, de ha nem konkretizáljuk a @RequestMapping annotációban külön paraméterrel, akkor véleltlenszerûen fog eldõlni h melyik fog lefutni.
	Ennek kivédése tehát:
	
	@Controller
	@RequestMapping("/project")
	public class ProjectController {
		
		@RequestMapping("/add", method=RequestMethod.GET)
		public String addProject(){
			System.out.println("invoking addProject");
			return "project_add"
		}
		
		@RequestMapping("/add", method=RequestMethod.POST)
		public String saveProject(){
			System.out.println("invoking saveProject");
			return "project_add"
		}
		
		@RequestMapping("/add", method=RequestMethod.POST, params={"type=multi"})
		public String saveMultiYearProject(){
			System.out.println("invoking saveMultiYearProject");
			return "project_add"
		}

	
	}

Model

	A model, amit megkap a view paraméterként általában map collekcióként van megvalósítva.



Autowiring

	Az applicationContext.xml-be tegyük bele a bean definíciónkat h elérhetõ legyen a DispatcherServlet és a controllerek számára is.
	
	@Controller
	@RequestMapping("/project")
	public class ProjectController {	
	
		@Autowired
		private ProjectService projectService;
		
		@RequestMapping(value="/find")
		public String find(Model model){
			model.addAttribute("projects, this.projectService.findAll());		A project/find url re el fog vinni a projects jsp-re ahol a projectService által megkeresett listát, a "projects" változón keresztül elérve feltöli azt a model-bõl.
			return "project_add"
		}


		
Tag Libaries
	<%@ %>	//Ez egy direktíva, a jsp oldalak tetjén hozzuk létre õket.
	Spring MVC 2 Tag Library-vel rendelkezik:	
		Az egyik a general Spring Library
		A másik segít formokat építeni (létrehozni, és beépíten a SpringFramework-be)
		
		Spring url tag:
			H ne kelljen mindig beírni a tomcatben lévõ webalkalmazás címét az url-be ezért azt kiszervezhetjük:
				<%@ taglib uri="http://wwww.springramework.org/tags" prefix="spring" %>
				
				<spring:url value="resources/save/">
			
		
		Form tag library: A jsp oldalak építéséhez.
		<%@ taglib uri="http://wwww.springramework.org/tags/form" prefix="form" %>
			Használata:
			
				<spring:url value="resources/save/" var="formUrl">	//ezt nem trehetjük be az action be, ki kell szervezni.
				<form:form action="${formUrl}" method="POST" modelAttribute="">	//A sima html-es form tag-re már nincs szükség.
				</form:form>
				
		Input: adatokat lehet vele bindoolni a model attribute-hoz.
			Kell hozzá: 
			<%@ taglib uri="http://wwww.springramework.org/tags/form" prefix="form" %>
		
			<fomr:input path="a filed name on the model" class="form-control" id="resource-name"/>
				
			Controlleren:
				
				@RequestMapping("/resource/save")
				public String save(@ModelAttribute Resource resource){
					System.out.println(resource);
					return "resource_add"
				}
				
		Select Tag:	//Legördülõ lista, dinamuikusan szeretnénk hozzá adni, ezt oldja meg.
		<form: select path="ide fog kerülni a kiálvasztott?" imtems="innen válogatja ki ${typeOptions}"/>
			
		Radio Buttons:
			<form:radiobuttons path="unitOfMeasure -ide fog letárolódni?" items="${radioOptions}"/>
		
		Checboxes 
			<form:checkboxes path="indicators -ide fog letárolódni?, ez egy collection(array)" items="${checkOptions}"/>
			
		TextArea
			<form:textarea path="note -ide fog letárolódni?)" class="form-control" rows="3"/>
		
taglib
	<%@ taglib uri="http://www.springframework.org/tags" prefix="c" %>	//foreach tag behúzása a jps-n

	<table class="table table-hover">
		<tbody>
			<tr>
				<th>Name</th><th>Sponsor</th><th>Description</th>
			</tr>
			<c:forEach items="$projects}" var ="project">
				<tr>
					<td>${project.name}</td><td>${project.sponsor}</td><td>${project.description}</td>
				</tr>
			</c:forEach>
		</tbody>
 	</table>	
	
	
URI templates: Adatok visszadása a controllernek URI templetek segítségével
	url-be tehetõk.

	<table class="table table-hover">
		<tbody>
			<tr>
				<th>Name</th><th>Sponsor</th><th>Description</th>
			</tr>
			<c:forEach items="$projects}" var ="project">
				<tr>
					<td><a href="<spring:url value="/project/${project.projectId}"/>">${project.name}</a></td>
					<td>${project.sponsor}</td>
					<td>${project.description}</td>
				</tr>
			</c:forEach>
		</tbody>
 	</table>	
	
	Ehhez kell egy új Controller is
	
		@RequestMapping(value="/project/{projectId}")
		public String findProject(Model model, @PathVariable ("projectId") Long projectId){
			model.addAttribute("project", this.projectService.find(projectId))
		}
		
Method Arguments



Advanced databinding // Pl arra az esetre ha az adatok összetett typusok

	Session attrbitutes stores datas between requests
	
	Összetett objektumok:

		<div class="form-group">
			<labale for="sponsor-name">Sponsor</label>
			<form:input id="sponsor-name" ccssClass="form-contorl" path="sponsor.name"/>		//Egy Sponsor object name field-je
		</div>
		
		<div class="form-group">
			<labale for="sponsor-phone">Sponsor Name</label>
			<form:input id="sponsor-phone" cssClass="form-contorl" path="sponsor.phone"/>	
		</div>
		
		<div class="form-group">
			<labale for="sponsor-email">Sponsor Email</label>
			<form:input id="sponsor-email" cssClass="form-contorl" path="sponsor.email"/>	
		</div>

	Listák:
	
		<div class="form-group">
			<labale for="poc">POC</label>
			<form:input id="poc" ccssClass="form-contorl" path="pointsOfContact[0]"/>		// 0.indexre fog letárolódni 
		</div>
		
		<div class="form-group">
			<labale for="poc2">POC2</label>
			<form:input id="poc2" ccssClass="form-contorl" path="pointsOfContact[1]"/>		// 1.indexre fog letárolódni 
		</div>
		
		<div class="form-group">
			<labale for="poc3">POC3</label>
			<form:input id="poc3" ccssClass="form-contorl" path="pointsOfContact[2]"/>		// 2.indexre fog letárolódni 
		</div>
		
	@ModelAttribute: Két kontextusban létezik:
		Ha metódus paraméterbe tesszük az azt jelenti hogy ebbe szeretnénk visszakapni az adatokat a modelltõl:
			
			@RequestMapping("/save")
				public String save(@ModelAttribute Resource resource){	//Ha nem kapunk resource-ot, akkor a default constructor szerinti értékek kerülnek beállításra.
					System.out.println(resource);
					return "resource_add"
				}

		Ha magán a metóduson hozzuk létre az azt jelenti hogy jelezzük ez a metódus bele fog tenni egy objektumot a modellbe, mint attribútum
			@ModelAttribute("checkOptions")
			public List<String> getChecks(){
				return new LinkedList<>(Arrays.asList(new String["Lead Time, "Special Rate", ""Requires Approval]));
			}
			
			Tehát már nincs többé szükség erre a metódusra:
				List<String> checks = new LinkedList<>()(Arrays.asList(new String["Lead Time, "Special Rate", ""Requires Approval]));
				model.addAttribute("checkOptions", checks);


Session attributes: a model attribútumokat tudjuk vele tárolni requestek között.
	Normális esetben a servlet attribútumokat a servlet api segítségével tárolnánk.
		@SessionAttribute("resource") //Annak a modell attribute-nak a neve, amit meg szeretnénk tartani session-ök között.
		Csak egy adott controlleren mûködik, kontrollerek között már nem.

		Ha szeretnénk removolni az attribútumokat a session-bõl, akkor:

		@RequestMapping("/save")
		public String save(@ModelAttribute Resource resource, SessionStatus status)	//Ezzel a SessionStatus-szal tudunk törölni, pontosan még nem tudom h hogy
			System.out.println("Invoking save)()";
			status.setComplete();
			return "resource_add"
		}



@ResponseBody 
	A controller handle metódusa közvetlenûl ír a HTTP responsebody-ra, nem fog bekerülni az adat a modelbe.
	Hasznos lehet email küldésnél.
	
	@RequestMapping("/request")
	@ResponseBody
	public String save(@ModelAttribute ("resource")Resource resource){	
		//Send out an email for request
		return "The request has been sent for approval";		//Ez lesz szövegesen kírva, nem pedig egy view-ra fog navigálni
	}
	
@RequestBody
	A response body ellentéte, a HTTP-request fut be ide, be tudjuk tenni a controller handle metódusába.
	
	@RequestMapping("/request")
	@Response
	public String save(@RequestBody String resource){	
		System.out.println(resource);
		return "The request has been sent for approval";		//Ez lesz szövegesen kírva, nem pedig egy view-ra fog navigálni
	}

Validation: CommandObject:
	A validátor osztályunknak implementálnia kell a Validator interfészt (org.springframework.validation)
		A megvalósításra váró metódusok: 
		
			public class ProjectValidator implements Validator{
		
				public boolean supports(Class<?> arg0){			//Megmondja h melyik osztályt validáljuk:
					return false;
				}
				
				public boolean supports(Class<?> clazz){		//Lehetséges implementáció
					return Project.class.equals(clazz);
				}
				
				A Másik:
				
				public void validate(Object obj, Errors erros){
					Project project = (Project) obj:			//Nyugodtan megtehetjük a checket, mert az elõzõ metódus már validálta.
					if(project.getName().length < 5){
						errors.rejecttValue("name","project.name","That is too short");	//Az errors-ba fognak bekerülni az errorok.
					}
				
			}
		--------------------------------------------
			
		Ahhoz h ezt a validátort használni tudjuk a controlleren azt jelelzni kell a controlleren egy binder metódussal (be kell regisztrálni azt):	
			
		@InitBinder
		public void initBinder(WebDataBinder binder){
			binder.addValidators(new ProjectValidator())
		}
			
		--------------------------------------------

		A történet itt még nem ért véget, szükség van még egy validátor API a pom-xml ben:
		javax.validation
		
		Bele kell tenni egy @Valid annotációt arra a paraméterre, amit szeretnénk validálni
		
		@RequestMapping("value=/add", method=RequestMethod.POST)
		public String savaProject(@Valid @ModelAttribute Project, project, Errors erros){	//közvetlenûl a modelAttribute után kell megadni az Errors, ebbe fognak bele kerülni az õ hibái.
			if(!errors.hasErrors()){
				System.out.println("The project validated.");
			}else{
				System.out.println("The project did not validate.");
			}
			
			System.out.println("invoking saveProject");
			System.out.println(project);
			return "project_add";
		}	
		
		
	Bean Validation: A Spring MVC biztosítja a JSR303(Bean Validation Specification) használatát a framework-ben, ahhoz h használatba vegyük implementálni kell,
		amit importálni kell Maven-nel: org.hibernate hibernate validator
		
		Pl.:
			Tegyünk egy @NotBlank Annotation-t egy fieldre és használjuk a fenti leírással együt.
			
				@NotBlank(message="You must provide a description")
				private String description;
				
				Tegyük ki a form-ra:
				
				**project_add.jp**			
				
					<div class="form-group">
						<labale for="project-name">Description</label>
						<form:textarea ccssClass="form-contorl" path="project" rows="3"/></form:textarea>		//Egy Sponsor object name field-je
						<form:errors path="description"/>
					</div>
				
				
	@ExceptionHandler
		
		**Controller.java**
			
			@ExceptionHandler(Exception.class)						//Array of exceptions can be given here
			public String handleError(HttpServletRequest request){							
				return "controller_error";							//A jsp ahova elnavigáljon hiba esetén
			}
	
		
	HandlerException Resolver
		Exception-ök globális szinten való kezelésére
		
		**GlobalHandlerExceptionResolver**
		
		@Component
		public class GlobalHandlerExceptionResolver implements HandlerExceptionResolver{
		
		@Override
		public ModelAndView reseolverException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception exception){
				ModelandView mav = new ModelandView()
				mav.setViewName("global_error");
				return mav;
		}
		
ViewResolution		
	View are rendered using a ViewResolver
	
	Views come in many formats such as JSP, PDF, JSON nem muszáj grafikusnak lenniük tehát a view-oknak.

	View and ViewResolver are Interfaces and they have many interfaces.
	
	Process form requests using POST->REDIRECT->GET
			
			
ChainingViewResolver

	A már meglévõ viewResolver 
	
		<bean id="viewResolver" class="org.springframework.web.servlet.view.internalViewResolver">
			<property name ="prefix" value="/WEB-INF/views/">
			<property name ="suffix" value="/WEB-INF/.sjp">
		</bean>	
	
	mellé betehetünk újakat is
		
		<bean id="viewResolver" class="org.springframework.web.servlet.view.XmlViewResolver">		//Rámutat egy xml file-ra amit képes mappelni egy logicalViewName-et egy adott viewFile-ra
			<property name ="location" value="/WEB-INF/spring/views.xml">
		</bean>		
			
ContentNegotiatingViewResolver: A többi viewResolverrel kommunikál a file kiterjesztés vagy a httpRequest header függvényében.			
			Add jackson-databind artifact to Maven(com.fasterxml.jackson.core jackson-databind)
			Más viewResolver-eket tartalmazhat.
			
		<bean id="viewResolver" class="org.springframework.web.servlet.view.contentNegotiatingViewResolver">
			<property name ="viewResolvers">
				<list>
					<bean id="viewResolver" class="org.springframework.web.servlet.view.internalViewResolver">
						<property name ="prefix" value="/WEB-INF/views/">
						<property name ="suffix" value="/WEB-INF/.sjp">
					</bean>

					<bean id="viewResolver" class="org.springframework.web.servlet.view.XmlViewResolver">		//Rámutat egy xml file-ra amit képes mappelni egy logicalViewName-et egy adott viewFile-ra
						<property name ="location" value="/WEB-INF/spring/views.xml">
					</bean>						
				</list>
			</property>
			<property name ="contenetNegotiationManager">
				<bean class="org.springframework.web.accept.ContentNegotiationManager">
					<constructor-arg>
						<bean class="org.springframework.web.accept.PathExtensionContentNegotitationStrategy">
							<constructor-arg>
								<map>
									<entry key="json" value="application/json"/>							//Ezeket a formátumokat kezelje
									<entry key="xml" value="application/xml"/>
								</map>
							</constructor-arg>
						</bean>
					</constructor-arg>
				</bean>
			</property>
			<property name ="defaultViews">
				<list>
					<bean class="org.springframework.web.servlet.json.MappingJackson2JsonView">			// Jackson library segítségével az objektumainkat json-ba alakítja
					</bean>
				</list>
			</property>
		</bean>		
			
	
Redirect: A re POST elkerülése végett hasznos, h ne tudjon kétszer klikkolni ugyanarra submitra, amíg az várakozik/vagy ha újrahívjuk az oldalr F5-tel akkor se küljdünk újra.

	return "redirect:/ahova_menni_szeretnénk";




















	
		
		