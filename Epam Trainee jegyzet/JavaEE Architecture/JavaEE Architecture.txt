Fel kell ismerni azokat az üzleti követelményeket, amik kihatnak a technikai követelményekre.
	-> Csökkenti az újdonságok bevezetésének fájdalmát.
	
Elsõnek olyan architektúrális döntéseket kell meghozni, amiket késõbb nagyon nehezen lehet csak megváltoztatni.

Nem csak a funkcionális, de a minõségi követelményeket is eleget kell tenni.

Az architektúra az egyes komponensek struktúrájáról, a komponensek közti kapcsolatokról, az elevekrõl és irányvonalakról szól.

Cassandra: NoSql adatbázis: Nem csak sql-lel éehet elérni, nem tudják nyújtani a konzisztencia garanciákat, tranzakcókat. Akkor használunk ha nem valamilyen kritikus rendszert használunk.

LDAP: felhasználók bejelentkezésére szolgáló protokol.

Egy szolgáltatás local v remote legyen?

	Jól meghatárorozott interfészek kellenek a loose coupling eléréséhez.
	
	Optimalizáljuk a különbözo rendszerek között hívások számát-> teljeseítmény romlás lehet.
	
	Hálózati kommunikáció biztonságát titkosítással kell támogatni -> a teljesítmény csökkenhet.
	
	Nem csak üzleti, technikai problémákból adód kivételeket, hibákat is le kell tudni kezelni.
	
	Minden egyes paramétert át kell tudni vinni a hálózaton, sorosítani lehessen oket.
		Javában referencia alapján adjuk át az értékeket, de a hálózati kommunikáció során ez Pass-by-value val történik, így nem történik meg alapból a visszacsatolás.
		

Cluster
	
	Célja: egy szolgáltatásként tudjunk tekinteni több számítógépre. -> komplexitás csökkentése.
		Növelni lehet dinamukusan a kapacitást, a rendelkezésre állást. Költséghatékony.
		
		
	Ezeket a clustereket autómatizálni kell tudni (orchestration: a konfiguráció management irányítása) (hasonló ~identikus szolgáltatások menedzselése)
		Virtuális gépek mozgatása az igényeknek megfeleloen.

Az alkalmazásunk egy csomagolt file lesz a végén, egy artifact. Configurálni kell a kiszolgáló környezetet, ezt a p.: xml-t nem az alkalmazással együtt szállítjuk.
	Ennek a szállítási feladatnak a végrehajtására, lefuttatására vannak külön eszközök, pl.: Puppet, Salt.
		
Session-ök (Munkafolyamatok)
	Milyen felhasználó van bejelentkezve a túloldalon. 
	Az azonosítás módjai:
		Cookie-Session Id
		URL paraméterként
		HTTPS: alalpból tudja követni h ki van a másik oldalt.
		
	Fontos h a munkafolyamatok a szerverek között láthatóak legyenek.
		Megoldás: Sticky session: A kiszolgáló összes kérését ugyanoda irányítjuk egy Load Balancer seítségével (Neki nagyon okosnak kell lennie).
		Skálózdással is lehetnek problémák, a balancernek gyorsan kell tudni azonosítani.
		Egy pl.: sql adatbázisban lehetnek(közös adattár) a session adatok, sorosíthatónak kell lennie.
		Memóriában is tárolhatjuk a session-öket. Több helyen tároljuk, így védekezünk a meghibásodások ellen, így a load balancernek sem kell túl okosnak lennie, viszont egy bizonyos méret után már nem jól skálázódik.
			Meg kell találni az egyensúlyt hogy a munkafolyamatok mindenhol elérhetoek legyenek egy csomópont kiesése esetén illetve a teljesítmény/ kapacitás között.
			Pl.: Redis program a sessionök menedzselésére. Oracle coherence meg tud bírkózni nagyranövo renszerekkel is. De a TomCat is meg tud bírkózni Session Replikációs feladatokkal.
			
Deployment:
	A felhasználó számára "láthatatlan legyen" a váltás.
	
	Lehetoségek: Az új felhasználók a friss verziójú kliensre csatlakoznak fel. 
	Sok verzió esetén sok duplikációra van szükség ha fallback-kelni akarunk.
	A LoadBalancer-nek okosnak kell lennie h irányítani tudja a felhasználókat.
	
	Új virtuális gépek autómatikus deployolása autómatikusan. Kiépített infrastruktúra -Felho.
	
	
	
Failover: Ha kieseik egy kiszolgálló. azt is tudni kell kezelni.
	Transzparens módon történo átirányítás.
	Monitorozni kell a node-ok válaszidejét. Idokorlátos válaszadás a kérésekre.
	Kell h maradjon szabad számítási kapacitás.
			
			
			
Caching: Transzparens adattár, aminek segítségével a jövoben várható krések gyorsabb kiszolgálása valósítható meg.	
	
		Ez egy Cross Cutting Concern: Az egész rendszerben megjelenhet: adatbázisban, külön kiszolgálókban lokásis cache-ként, processorokban is többrétegu lehet, a mrevlemezek is tartalmaznak cache-et, sot még a böngészok is.
		A kétszintu cache menedzselésre a többszálúság miatt lehet szükség.
		
		Problémák:
			Mikor és mit írunk(felül),
			Mikor törlünk (Cache eviction: eseményhez kötött törlés)
			Konzisztenica a cache csomópontok között.
			Általában read-only cache-t használunk.
	
		Cache-elési algoritmusok:
			Least Recently Used: idobélyeg seígtségével a legrégebbit távolítjuk el.
			Least Frequently Used: Statisztikát is építettünk, melyik adatot hányszor értük el az adott idoben.
			FIFO
		
			Nem lehet elore megmondani h melyik a leghatékonyabb, az adott alkalmazástól, annak környezetétol függ.
			
			Néha a Random is jó lehet.
			
			Adaptive Replacement Cache (Arc) állítólag jobb mint a Lesat Frequently Used.
			
	Elosztott cache alaklamzása esetén fellépo problémák:
		Hasonló mint a session-ök esetén.
		Konzisztencia esetén eros, vagy csak eventually.
		
		
	Cache konfiguráció:
		Ne magunk írjunk, mert lehet h futni fog a többprecosszoros környezet által biztosítot elonyöket kihasználva, de lehet h nem lesz helyes.
		Cache konfigurálásnak lehetoséegei:
			-XML-bol, AOP,n keresztül adjuk meg h milyen metódusokat szeretnénk kesselni. Illetve pointcut-okkal lehet megadni h mikor szeretnénk kiüríteni. (Edit metódus estén mehet az evict)
			Annotációkkal. Spring @Cacheable-kesselheto, nem peddig kesselni kell!
			JCache (JSR-107) szabvány.
		
		Object pool vs Cache.
		
			Object pool: db-k kapcsán, a kapcsolatokat lehet pool-ozni.
			Többszálsúg esetén a szálakat lehet poolozni, mivel dárga ezért el szoktuk menteni h a késobbiekben újra felhasználhassuk.
			
			A Cache másolatot tárol el egy olyan adatból amit gyakran el szeretnénk érni, drága lenne kiszolgálni újra, vagy elohízni. Mindegy h más is olvassa azt az adatot.
			
			Pool: inicializát objektumokból tárol el többet, töröl, hoz létre. Mindegy h a poolból melyiket kapom. Ha vissza akarom adni, akkor olyan állapotban kell visszaraknom, ahogy kaptam.
				Thread pool (általában önállóan konfigurálja egy weserver, servlet konténer), connection pool. Nehéz meghatározni h mekkora legyen a pool mérete. Dinamukusan változtatható a méret.
				
				
	
Multi layered architecture

	Ne használjunk túl sok absztrakciót.
	Menedzselt gépek, virtuális gépek, hatalmas áttörés (plusz réteg)
	
	Layer: Szoftveres, logikai szervezés.
	
	Tier: Fizikai elosztása a moduloknak, komponenseknek.
	
	Egy Layer több Tier-be is elkülönulhet.
	
	1 rétegu
	
		Monolitisuk rendszerek(1-2 ember látja csak át az alkalmazást, a többiek a zavarosban halásznak. Biztonsági problémák is lehetnek.) -> 
	
	2 rétegu
	
		Két rétegu architektúrák (db elkülönul az üzleto logikától/megjelenítéstol)
		//Adatbázis motor csere -> üzleti kockázat
	
	3 rétegú
	
		Presentation (intekakció a szoftver és a felhasználó között, adatok megjelenítése, validáció itt is lehet: hibás e-mail cím)
		
		Business (Kalkuláció, validáció itt is lehet: hibás e-mail cím). Üzleti logikai számítások.
		
		Persistency
			Kommunikáció a bv-vel, üzenet küldo rendszerekkel, tanzakció menedzsment. Ahogy az adatot elo tudjuk állítani. Egyéb információs rendszerekkel történo összekapcsolódás.
		
	Több rétegu
		
		Mediátor layerek:
			Application layer: tehnológia specifikus részletek. a Business és a Presentation között. Adatkonverziós feladatok. Servlet-módosít az üzleti logikán. 
				Eloállítson egy olyan modellt, ami alapján a megjelenítés fel tud épülni. Össze gyujtse a szükséges adatok.
			Data Access Layer: Üzleti objektumok és a relációs adatbázis közötti kapcsolatot tudjk megvalósítani.
	
	Vertical Layer: Nem tudjuk egyetlen réteghez sem kötni, mindenhol jelen lehet: Security, Logging, Caching: -> Cross-cutting concerns
			Business Logic (autentikáció, authorizáció). 
			Layerek közötti kommunikáció. 
			DI framework segítségével lehet a függoségeket feloldani
			//Facade alkalmasa réteegzett architektúra kialakítására.
			
			
	JaxP: Procedúrulis jellegu feldoglozások. Technológiák: Sax, Stax, DOM
	JaxB: Annotációkkal lehet összekötni egy xml-lel az adatiankat.
	
	Jax-WS: Nehézsúlyú webalkalmazásokra.
	Jax-Rs: Megengedobb webszolgáltatások, REST.
	
	Dependenciák csak fenntrol lefelé történjenek. Az egymás alatt-fölötti layerek csak egymással kommunikálhatnak.
	
	Strict interaction: Minden réteg csak a mellete lévovel kommunikáhat.
	
	Ha nagyon egyszeru akkor is át kell vezetni az üzleti logikán (legfeljebb csak delegálunk)
			
			
	Validáció: alaklamzás logika része. (Gyerekek száma nem lehet negatív.)		
			
			
JEE Kontéer model

	Konténer: futató környezet: technikai jellegu szempontokat hozzátegyen a mi komponenseinkez. Cél: a fejleszto csak az üzelti logikára tudjon koncentrálni.
	
	Tipikus feladatokat zelje helyettünk a keretrendszer:
		Állapotmnedzsment: példányosítani az objektumainkat.
		Tranzakciók. Ne nekünk kelljen indítani, exception-ök esetén autómatikus legyen a rollback.
		Többszálúság
		Eroforrás pool-olás
		Biztonság
		Komplex, alacsony szintu aspektusok.
		
	Konténer típusok:
		Servlet kontér (TomCat):
			A servletek életciklusát kezeli.
			Egy url-címet a web-xml cím segítségével egy servlethez mappeli.
			Hozzáférés kezelés.
			
		Spring IoC kénténer
			+bean-ek kezelése
			+DI

		EJB konténer:
			JavaEE szabvány az EJB-a Spring alternatívája.
			+Component pooling: 
			+Elosztott futtatás: EJB-k transzparens módon való kezelése (paraméterek sorosíthatósága, referencia v paraméter szerinti átadás)
			+idoztéssel kapcsolatos szolgáltatások.
			+Aszinkron metódusok
			+Megadhatjuk h mely metódusokat futtathatjuk párhuzamosan és melyikeket nem.
			+session menedzsment.
			
			Beanek típusai:
			
				Statefull session bean: Van állapota, attribútumai, poolozusra van szükség, egy munkafolyamathoz-egy felhasználóhoz kötött.
				Stateless session bean: Nincs llapota, attribútuma, ezeket is csak egy szálon tudjuk elérni.
				Singleton: A többszálúság egy objektumon fog lecsapdóni.
				MessageDrivenBean: JMS: üzenetküldéshez kapcsolódik.
				
				Összességében tehát a többszálsúgágot nehéz elrintani, Spring esetén viszont egy adott objektumot több szálról szoktunk elérni.
				
				Passzíválás: memória spórolás miatt ki tudunuk menteni olyan objektumot (sorosítani) amire épp nincs szükség, viszont session-höz kötött. 
				
				Spring esetén figyelni kell a többszálsúgágra, mert alapból singleton bean-eket kapunk, amiket többszálról lesznek kezelve.
		
		
		
		
JavaEE Architecture - Typical patterns (Tipikus minták)

	Mode-View-Controller: 
	
		Azt akarjuk különválasztani h hogyan áll elo az információ a megjelenítéstol.
		Controller: figyel a felhasználó által kiváltott eseménykre elvégzi a modellen az ehhez tartozó változásokat.
		A view megvalósítja az observert, a model az observablet, és egy interfészen keresztul megfigyeli a modell állapotaváltozásait és így nem kell köztük közvetlen kapcsolatot teremteni.
		
		Interakciók: a kontroller küldhet utasításokat a modellnek h frissítse magát ha valamilyen interakció jön. A modell értesít a view-t az observer mintán keresztül. A view kérdez folyamatosan h volt-e változás.
		A kliens folyamatosan kérdezgeti h jött-e be valami új sor (Push notification)
		
		A view kirajzolja a modell belso állapotát.
		
		Webes környezetben ritkán kell observer mintát alkalmazni, desktop alaklamzásokban viszont kötelezo.
			
			A Modell View hoz hasonló, annak derivatívája: 
				Model View Presenter
				Model View ViewModel: Autómatikusan frissítések interaktív felületeken. Spingle Page Application-ök esetén nagyon sokat segít. Data binding a komponensek között. Scope-okra történo felbontás segíthet.
		
		
	Session facade:
	
		Eros csatolás elkerülése. Szükség esetény könnyen cserélhetjük az implementációkat.
		
		Magas szintu hozzáférés nyújtása valamilyen szolgáltatáshoz. Nem definiálunk új funcionalitást. A legtöbb amit megtehet h továbbhív más üzleti logikai komponenshez, esetleg átkonvertálja az eredményt egy másik komponens segítségével.
		
		A logikailag összefügguo komponenseknek legyen külön-külön facade-je.
		
		Nevében is utalunk rá: ..Facade
		
		Lehet spórolni a hálózati kommunikáció terén, össze tudunk gyujteni több hívást egy hívásba. Ki tudjuk kényszeríteni h az objektumainkat helyesen használják (a megfelelo paraméterekkel, a hívások egymásutániságát).
			Tranzakciós határként alakalmazható.
			Deklaratív biztonság és cache menedzsmentnek is jó célpontja.
		
		
	Data Transfer Object (DTO)
		
		Egyszeru adathordozó osztály, arra jó h csoportsosítson egymással valamilyen szempont szerint összetartozó attribútumokat. 
		
		Nem egy üzleti objektum, nem egy entitás, csak azért hozzuk létre h az adatátadást elosígítse. Egy képernyon való megjelenítés.
		
		Minden szükséges adatot csomagoljunk össze, de csak a szükségesektet. 
		
		Itt kell eltárolni a sorosítási mechanizmust ahogy át kell érjenek a hálótazon //?
		
		Nem tartalmazhat olyan logikát ami miatt tesztelésre lenne szükség (csak getterek, setterek legyenek)
	
	
	Data Acces Object (DAO)
	
		Egy adapter egy koponens és egy adatforrás között.
		
		Adatelérést segítik az entitásokhoz (respository)
		
		Elválasztjuk az alkalmazáunkat attól h hogyan érhetjük el az adatokat. 
		
		Figyelni kell h ne fedjük fel az adatbázisunk struktúráját.
		
		Nem szabad visszatérni menedzselt entitással az objetbol.
		
		
	Business delegate

		Egyes rétegek távoli eljáráshívásainak esetén elreji a hálózati kommunikáció közti nehézségeket. Architektúrális megoldások elfedése.
		A kommunikáció sajátosságait lekezeli.
		Elrejthetjük h hogyan találkuk meg a másik felet,
		Illetve hálózat és infrasktruktúrális specifikus kivételeket.
		
		
	Transformer

		Modellek között kell transzformálni. Adattárolás és üzleti logikai réteg közti átvezetés.
		Cél: Belso objektumok között ne adjunk ki rétegek között.
		A hívó felett függetlenné tesszük az alatta lévo rétegektol. 
		
		
Domain Modell

	OO segítségével könnyebben karbantartható a problém.
	
	Az üzleti logikát funkcionális dekompozíciókkal vaslósítjuk meg.

	Igazából procedúrulisan(egymás utáni parancsokkal) kódoljuk le az egésze többrétegu alkalmazást.
		Nem igazán érheto tetten az encapsulation, se az information hiding.
		
	Anemic domain model:
		Állapotmentes a logika. Data Driven design könnyne követheto (Adatbázis modellbol kezdunk építkezni).

		//Domain driven design könyv


		
Optimistic Locking		
		
	Read lock: Aból lehet több párhuzamosan, nem za varják egymást.

	Write lock: Nem lehet több párhuzamosan.
	
	Mechanisms:
		
		Pessimistic lock: Ha elkezdem szerkeszteni, akkor ráteszem a lockot h más ne tudja, ha végeztem, akkor peig leveszem.
		
		Optimistic locking (nem fordulhat elo deadlock): 
			1, Elmentem hogy milyen verzióval/time-stamp kezdtem a tranzakciómat, 
			2, Megcsinálom a módosításokat,
			3, Mielott beírnám megnézem h változott-e a verzió/time stamp, ettol függoen döntöm el h commit v rollback.
			
			
		Deadlock: nem tudunk továbblépni, mert 2 tranzakció egymásra vár. Mind a ketto arra vár ami a másiknak megvan, ilyenkor nem tudnak önhatlamúan továbblépni.
		
		JPA optimistic locking megoldása: @Verison egy long version-ra.
		
		
Nem funkcionális követelmények: A rendszer muködését tudjuk megítélni vele. Hogyan látja el a funkciót?
	Rendelkezésre állás
		Folyamatosan figyeljük(pingeljük) monitorozás.
		Hány kilences legyen az elérhetoségi arányban. 90%. 99%, 99.9%
		//A tranzakciók konzisztens állapotból konzisztens állapotba viszik a rendszert.
		
		Javítás:
			Szavazás h pl. egy loadbalancer kiesik
			Active redundancy-folymatosan ottvan egy csere eszköz amire át lehet irányítani a forgalmat.
			Passzív redundancia: pár perc mire képes lesz átvenni a fealadatkört
			Spare: ott van a raktáron: néhány óra.
			
		Újra muködésbe hozni egy csomópontot:
			Shadow oeration. Ugaynazt a választ adná mint egy élesen muködo kiszolgáló.
			Az állapotot újra szinkronizálni kell, a session-öket újra át kell venni.
			Checkpoint-rollback -> visszaállunk a legutolsó helyes konfigurációra.
	
	Biztonság
		Elso sorban hogyan elozzük meg a támadásokat
		Autentikáció/Autorizáció
		Lehallhathatóság elleni védelem (https jó szolgálatot tesz)
		Csak a szükséges adatokat küldjük át.
		A támadás detektálására való felkészülés. Behatolás érzékelés(Gyanús folyamatok valaki el akarja kérni a teljes db-t)
		Biztonsági mentések.
			
			Leggyakoribb sebezhetoségek:
				SQL Injection. Nem megfelelo escape-eléssel áll össze az sql querry.
				Broken Authentication and Session Management: Session id ne jelenjen meg url-ben.
				Cross-Site Scripting: Ha mi is adhatunk meg tartalmat, pl.: javascript beadása szövegmezoben.
				Insecure Direct Object Reference: URI alapján nem ellenorzi konkrétan.
				Security Misconfiguration: valamelyik xml fileban sikerült valamit elrontani és emiatt nem válik érvényessé az általunk kívánt biztonsági beállítás.
				Sensitive Data Exposure: Olyan adatot nyújtok ki, amit nem volna szabad, nem sokat ér ha "hidden"-re állítom.
				Missing Function Level Access Control: valahogy meg kéne adni plusz jogosultásgi kritériumokat, de elfelejtjük.
				Cross-Site Request Forgery (CSRF): pl: egy domain-bol egy urlt ellopok és beépítem egy gombba, és az illeto be van jelentkezve. Ezért random stringeket teszünk az url-be.
				Using Components with Known Vulnerabilities: Felütöm a neten h milyen ismert hibái vannaj az adaott rendszernek.
				Unvalidated Redirects and Forwards: Nem nézzük meg h hova irányítjuk át a felhasználót. Olyan helyre irányítjuk át a felhasználót, ahova nem kéne. URL injection más néven.
	
	Teljesítmény
		Eroforrásokkal való gazdálkodás. Memória vs Processor libikóka.
		Számítási kapacitások optimalizálása: hetékonyabb rendezés (buborék -> guick sort, full table scan -> indexelés)
		Számítási ovehead-ek cseréje: JAva sorosítás helyett valami más.
		Óhajt csökkentése: Matematikia pontosság egy statisztikai feladatoknál.
		Eroforrásokhoz való hozzáférés priorizálása.
		Többszálúság: szinkronizáció lassulást okoz.
		
		Profiler: bottleneck-et keres futás közben. 
			Azt érdemes optimalizálni ami az ido 80%-ában fut.
	
	Karbantarthatóság
		Lokalizálni szeretnénk a módosításokat. Valamilyen interfész alá tegyünk be módosításokat.
		Limit possible options: Limitáljuk a saját lehetoségeinket h karbantartható maradjon a kód. Pl.: Nem írok 20 sornál hosszabb kódot. Kiírjuk a final-t h elkerüljünk késobbi hibákat.
		Information hiding. 
		Maintain existing interfaces: bocsátunk ki alapértelmezett implementációt az interfészünkhöz. Adapterek használata.
		Restrict communication paths: A kommunikációs útvonalak számának csökkentése. Facede-ek használata: odáig terjedhetnek ki a módosításaink.
		Kötési ido késleltetése: nem a kódunkban szeretnénk összekötni két komponenst, hanem futás idoben. Spring ebben segít: IoC. Polimorfizmus: interfészek mögött változhatnak az implementációk, késleltethetjük a csatolást.
			
	Naplózás
		AOP orientált környezet biztosítása: külön forrásfileban, konfigurációban jelenjenek meg.
		
	Tesztelhetoség
	Bovíthetoség
	Felhasználhatóság
	
	
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
		