Look insied!
Rod Johnson

Mit nyújt a Spring?:
	A core azt szolgálta h ne mi kézzel kötögessük össze a szoftverkomponenseinket, 
	hanem fejlesszük le egymástól amennyire lehet függetlenül, és mind a létrehozásukért, 
	életciklusukért feleljen egy külsõ rendszer, egy külsõ konfiguráció allapján. 
	Más építõkövekbõl más születhet.
	
	EJB-k használata nélkül. Cél az EE koplexitásának csökkentése.
	
	AOP/Proxy használat.
	
	Patternek köré épül a best practices.
		Singleton
		Factory
		Abstract Factory
		Template Method
	
	A Tomcat nem application sever, csak webserver viszont könnyû használni és könyebb súlyú. POJO alapú.
	
	Cél h a kódtól függetlenól mûküdjön a komponensek létrehozása és azok összefüggése.
	
	Kikényszeríti h a komponenseket egymástól függetlenül fejlesszük le, majd õ összekapcsolja.
	Ez a ragasztó/enyv a dependency injection lesz.
	
	Miért jó nekünk? 
		Egyszerû osztályokat írhatunk, 
		Tudunk az üzleti domainre fókuszálni.
		Növeli a tesztelhetõséget
		Növeli a karbantarthatóságot
		Növeli a skálázhatóságot
		Csökkenti a komplexitást
		A bizniszre fókuszál
		
Nagyon leegyszerûsítve a Spring HashMap objektumot rendszere(?).
	Ném-érték párok.
		
History:
	2003 alakulás
	2004 1.0 release
	2006 2.0
	2007 2.5-Annotációk, xml
	2009 3.0 Web services

	
	
Inversion Of Control: Az entitások feladják a controlt a saját függõségeik felett, 
a dependency injection egy lehetséges megoldás.

a "new" kulcsszóval létrehozott objektumok létrejönnek, de a Spring nem fog tudni róluk.

JNDI: Java Name Directory Interface. Egy szolgáltatást betolunk egy keretrendszerbe és ezen a néven keresztül bárki elérheti.
	A rendszer fogja tudni hogy az adott szolgáltatás amire hivatkozok hogy az hol van. (Service Locator)
	
	
Deklaratív:
	Ahelyett hogy azt írnánk le hogy hogyan csinálja meg amire nekünk szükségünk van,
	ehelyett azt írjuk le hogy mit csináljon, azt majd õ megoldja hogy hogyan.
	
Boilerplate kód eltûntetése: a felesleges dolgok eltûntetése, hibák származhatnak belõle. Minél több dolgot átadni egy másik rendszernek.

További ereje a Springnek, de a Core során nem jön elõ.
	Plusz modulok (Security). 
	JDBC kezelés.
	JPA/JDO támogatás.
	Erõs tranzakciókezelés: Vagy mind, vagy egy se-atomikus mûveletek.
		Ha a JDBC driver nyújt szolgáltatást tranzakciókezelésre akkor azt használja, ha nem akkor pedig ad maga.
	
POJO: semmilyen framework specifikus interfészt nem implementálunk, osztályt nem terjesztünk ki, 
	maga az osztály, amibõl a POJO lesz mindentõl függetlenül pusztán a domain-hez kötõdve jött létre.
	
Bean az egy speciális POJO: Amire speciális megkötések vonatkoznak:
	A popretyjeihez a getter, setter metódusok neveinek kell hogy tükrözze a property nevét (get-set-is(boolean)).
	
Sok dolog a Springben proxykon keresztül történik.

Java SE (J2SE régebben):
	Swing, Szálkezelés, XML

Java EE (J2EE):
	Specifikáció gyûjtemény:
		szerver specifikáció
		webszervíz specifikáció
		Java Beans specifikáció
		Amilyen szoftverek ezeket a specifikációkat teljesítik azok  Java EE-nek minõsûlnek.
		
Java Been:
	Entity bean:
	

A Spring az Enterprise Edition ellenpontjaként jött létre és az EE 6 már átvett sok dolgot a Springtõl.
	Hollywood principle: Don't call us, we will call you!
	Fókuszáljunk az interfészekre, arra bátorít, bele kénszerít.
	Spring nagyban javítja a tesztelés lehetõségeit.

A konfiguráció történhet xml-bõl illetve annotációk mentén, de akkor pont a lényeget veszítjük el.
	3-astól már egy külön Java osztályban is lehet. Csak hogy ne kelljen xml-hez nyúlni.
		
Proxy:
	Anniyban különbözik a rendes objektumtól, illetve annak meghívásától hogy azt körülbástyázza.
		Security proxy: valamilyen ellenõrzések: Van-e joga hozzáférni.
		Relay proxy: Elrejteni h ez az objektum nem is itt van, hanem a világ túlvégén.
		Lusta felépítés. A proxy-hoz eseik be a hívás és csak utána példányosítsunk.

		
Miben jobb az STS mint az Eclipse Spring pluginnel?
	Sokkal alkalmasabb a Springes feladatokra, viszont még az Eclipse-nél is lassabb.
	
Az XSD írja le h mi az ami benne lehet a Bean definícióban. A Bean xmlns-ében lehet konfigurálni a névteret.

Bean definíciók:
	Kürülbelül olyan a kapcsolat a defínicó és maga a bean között mint az osztály-objektum.
		A név és az id között az a különbség:
			A name alatt többet is megadhatok
				Konverterekkel lehet a megfelefõ típusúra kasztolni a Stringeket (mert a bean-ben ugye csak "Stringet" lehet alapból megadni).
					Vannak elepértelmezett konverterei a Stringnek.
			ref: -el id-ra vagy name-re hivatkozunk.
				Nullától kezdve hivatkozhatunk konstruktor paraméterre ha nevet nem adunk meg.
			Az id-ból csak egy lehet
			Ha a kettõ különbözik onnantól két azonosítón keresztül is elérhetõ lesz az adott bean.
			HA egyet sem adunk meg: A spring generál egy azonosítót, de mi nem fogjuk tudni elérni közvetlenül id-n keresztül, de lehet h nem is kell.
			
		Aliasokkal pl legacy rendszerek nameconvention-ok közti szakadékát hidalhatjuk át.
	Spring Bean: Azok az objektumok amiket a konfiguráció mentén létrehoz.
	
Az ApplicationContext lényegesen több plusz szolgáltatást tud nyújtani mint a depricated XmlBeanFactory
	Nem csak Stringként, hanem String[]-t is meg leeht adni a forrásokat.

	ApplicationEvent publication:
		Események elkapása: bean létrejött, megsemmisült.
	
<beans>
	<import resurces ="más beaneket is beolvashatunk egy xml-bõl"/>
<beans/>

 BeanFactory != FactoryBean
	BeanFactory: ami a beaneket állítja elõ, maga a Spring, az application kontext, akitõl a beaneket tudunk kérni.
	FactoryBean: az a bean amin keresztül legyártunk egy másik bean-t a BeanFactory-n keresztül.
	
Nem konstruktorral hozunk létra hanem reflection API-val.

init metódus: Az inicializáció végetérte után hívódik meg. Paraméterben lehet átadni az osztály uganolyan nevû függvényt.

Reflection API: A Javával együtt született. 
	Elkérem az objekt osztályát(getClass) és azon mahinálok, amiben minden benne van. 
		Hátránya h csúnya a kód és lassú. Valószínûleg rossz úton járunk, ha ilyet használunk.

Scope-ok beanekhez: Az összes bean singletonként jön létre alapból.

Az annotációk feldolgozása a Springen belül Bean postprocesszorokkal mûködik.

BeanPostprocesszor minden egyes bean inicializálása elõtt és után is le fog futni és hogy ki mivel foglalkozik azt majd maga eldönti. 

Logolás:
	Eredetileg Apache commons -log4j, de ki lehet cserélni bármi másra slf4j-re (ami egy API, ami alá azt rakok be amit akarok, pl logback)
	pom-xml-bõl ki kell szedni, azaz betenni az exclusion részbe. jcl: java commons logging
	 main-resources ba még be kell tenni egy logback xml-t h hová logoljon.
	 
Konstruktor argumentumnak ne adjunk neve.
	Reflection API-val privát konstruktort is elérhetünk.
	Konstruktorral való beállítás kiszûrheti a körkörös hivatkozásokat.
		Egy máglátás: ide a kötelezõket. (Közös álláspont kialakítása)

A setterek imádói szerint túl hosszú lesz a konstruktor.
	Egy máglátás: ide az opcionálisokat. (Közös álláspont kialakítása)
	
Bean definition lehetõségel (Mind a hárommal mindent lehet):
	XML
		Elõnyök: A kódtól teljesen független. Dokumentálja a komponenseket és a köztük lévõ kapcsolatot, ad egy architektúrális áttekintést.
		Hátrányok: Sok midenre jó, nem feltétlen kell mindenre használni
		bean.xml Tárolja a bean konfigurációkat.
			xsd: ez mondja meg h mi lehet egy névtérben.
		
	Annotációk
		Elõnyök: A feljlesztés során gyorsabb, egyszerûbb
		Hátrányok: A kódot teljesen ismerni kell.
		
	Java alapú konfiguráció (a kódtól független):
		Elõnyök: Azoknak akik utálják az xml-t. Típusbiztonság van. Nem kell editor, se konverter (Nem kell stringekkel operálni). 
		Jobban átlátható mint az xml. Fordítási idõben kiderülhet alapkonfigurációs problémák.
		Hátrányok: Nehezebben átlátható mint a külsõ konfiguráció.
				
		Típus biztos
		Java fejlesztõknek természetes.
		
		Használata:
			@Configuration a class-ra
		

Lehet bean-en belül bean-eket létrehozni. Az ogrének lehet olyan fegyvere ami nincs senki másnak.

Bean definíciók örököltethetõek.
		Lehet közös absztrakt bean definíció, belõle példány nem jöhet létre.
		
Összetett(compound) property:
	Address:
		city
		street
		ZIP
		
depends-on:
	Ha két bean nem függ össze, de valamiért fontos h az egyik hamarabb jöjjon létre, mint a másik, akkor a másodikra ezt az attribútumot rá kell tenni.
	
A lazy initialization springen belül nem annyira mûködik.

Autowiring:
		Hatalmas elõnye h összefüggésekket autómatikusan összefûz.
		Ha nem mûködik(több lehetõség), akkor nekem kell kibogarászni.
		
		
PopertyEditor
	Nem kell id.
	meg kell valósítani a PropertyEditorSupport setAsText() metódusát, ami void, mert egy result-ba állít be dolgokat.
	setValue(-val be kell állítani a visszatérési értéket)
	A custom editorokat be kell regisztrálni egy map-be a bean xml-ben.
	Map: Hogy a rendszer meg tudja mondani h az adott bemenethez milyen poerty editorra van neki szükség.
	
Converter
	Itt kell id.
	conversionService
	converter() generikus interfész önmagát adja vissza.
	Lista: id-alapján találja meg.
	
Spring Expression language: Value-ba tudunk írni kis kódrészleteket. Spring sajátja.
	Mit lehet vele csinálni?
		Értékeket elérni
		Szûrni
		Statikus metóduokat elérni
		
	SpEL: Spring Expression Language 
		Így adjuk meg: #{ <expression string> }
		
Bean definíciók alapján értelmezi a kollekciókat nem úgy mint magában a javában.


Autowiring:
	Arra jó h a függõségeket nem nekünk kell megadni, hanem a Spring kitatlálja és beilleszti.
	Attribútum a beatin tag-en defaultból no.
	Hogy mi alapján válassza ki (lehet egy attribútumot pramary-vé tenni h ha többet adunk meg, akkor azt válasssza.):	
	
		no (default)
		
		byName: property alapján megy végig, mivel a név is egyedi lehet benne, ezért nem okoz konfliktust
		
		típus lapján: futhatunk bele problémákba, mert több bean is lehet ugyanabból a típusból
		
		constructor: alapból típus alapján keres
	
	Az autowire csak ott fog keresni ahol nincs egyéb referencia.
	
	Reflection apival végignézi h milyen setter metódusok vannak és ahhoz név alapján megpróbál kereseni referenciát.
	
	Ha többet is talál exceptiont dob.
	
Springben minden exception unchecked.

PropertyPlaceholderConfigurer: Meg lehet mondani vele h hol keresse a külön kiszervezett db credentials property file-t.
	Profilos megoldás jobb lehet: Egy fileban van az összes credentials és indításkor meg lehet adni h melyik szerint konfigurálódjon.
	
Környezeti véltozók: "-D" kapcsolóval Javában

Spring konfiguráció: Meg tudom mondani h ez a konfiguráció ilyan profilnél él, ez pedig annál. Egyszerre több profil is élhet.

FactoryBean: ha olyan logikát kell belekötni ami maõgy az xml-ben nagyon macerás lenne, vagy meg se lehetne csinálni.

Annotációk: 5-ös javától. 
	Az annotációkat a Spring BeanPostProcessorokkal dolgozza fel. Ezeket aktiválni kell. Manuálisan, vagy az annotation config-tag gel õ majd beköti.
	Az annotációk egy része Spring specifikus, a többi lehet enterprise standard.
	
	Miket annotálhatunk?
		Osztályt
		Metódust (Konstruktor)
		Tagváltozót
		Paramétert
	
	Be kell õket kapcsolni a contextben.
		<context:annotation-config> (csak bekapcsol?)
		<context:component-scan base-package="com.epam.botor.domain"/>  (meg is keresi vmi?)
		
				
	@Required
		Tagváltozóra vonatkozik: Ezt valahol be kell állítani.
			A listák eleit figyelemen kívül hagyja, nem néz bele, hiába olyan típusú.
	@Autowired
		Mezõkre, setterre, Alapból típus, majd név alapján keres.
		Amire Autowired-et teszünk az egybõl Required-dé is válik azonnal
	@Qualifer
		Meg tudunk adni bizonyos szûrõ feltételeket. El kéne kerülni a használatát.
	@Componenet:
		Osztályra: Abból az osztályból csinál 1(és csak is egy) bean-t
		
	
JSR: Java Specification Request.

