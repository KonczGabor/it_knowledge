A belsõ szerkezetét módsoítjuk egy programonak úgy hogy könnyebben érthetõvé váljon, 
könnyebben tudjuk módsoítani anélkül h megváltoztatnánk a látható viselkedését.
Martin Fowler: Refactoring Improving the Design of Exsiting Code

Mielõtt új funkciót vezetnénk be érdemes refaktorálni (átalakítani a kód struktúráját)

Célok:
Javítja a design-t.
Kód olvashatóbb lesz.
Könyebben találjuk meg a hibákat.
Gyorsítja a jövõben a kódírást.
Kódduplikáció kerülése.

Tudni kell melyek azok a részek ahol megéri optimalizálni.

Mikor érdemes nekivágni?
Bad smelling: Mikor másodszor is arra járunk és erezzük h valami baj van.

Miket nehéz módosítani:
Már meglévõ adatbázismodellt.
Publikált interfészeket.
Rétegzett architektúrát.
Olyan kódot ami már eleve fordítás idejû hibákat ad.
Határidõhöz közel. 
Olyan ami nem fog változni a jövõben: pl.: Matematikai képletek
Olyan ami úgyis meg fog változni a jövõben.

-----------------------
Utaló jelek:

Kód duplikáció: struktúrából adódó
Hosszú metódusok

Nagy osztály, sok felelõsséggel

Paraméterlista (max: 3)

Divergens módosítás: Szerteágazó módosítás: nagyon sok helyen kell módosítani egy dolgot. Pl.: Új enum bevezetése-> switch-case esetek lekezelése.

Shotgun Surgery: Egy módosítást nagyonsok helyen kell eszközölni

Feature Envy: Egy osztály a szomszéd osztály attribútumaival foglalkozik

Data Clumps: Együttjáró adattagokat csomagoljuk össze

Mágikus konstans: nem tudjuk mi ez az attribútum

Primitív constants: Mindenre egy adott primitívet használ. Javában a String nem primitív, de nem szabad mindenre aszt használni.
SWITCH sem jó, objektum orientáltan kell helyettesíteni

Párhumzamos öröklés: Bridge tervezési minta segíthet hogy ne jelenjen meg mindkét oldalon ugyanaz.

Lusta osztály: Elveszítette a szerepkörét, már nem hasznos.

Spekulatív általánosítás: Felesleges jóslások a jövõre nézve

Temporary Fieldek: felesleges null ellenõrzések -> Ha leeht már a konstruktorban értéket kapjon az attribútum

Message Chains: Arra utal h a Demeter szabályt nem sikerült alkalmazni. 

Middle Man: Feleslegesen alkalmaztunk egy delegációt. Közbe ékelet szereplõ. A Facade nem ilyen, mert neki van oka a létezésre (Összefog).

Kellemetlen közelség: Az egyik osztály a másik attribútumaival van elfoglalva.

Alternatív osztályok különbözõ interfésszel: Két fejlesztõ külön-külön implementálják. Ilyenkor az egyiket meg kell szüntetni.

Incomplete Library Class: Nem teljes osztályok: Java util.date -> calendar

Adatosztály: Olyan osztály ami csak atribútumokat használ. A baj az amikor csak ilye osztályaink vannak és nincs felelõsségük.

Refused Bequest: Nem szeretnénk implemenálni az örökölt dolgokat. P.: Iterátor interface remove() metódusa
Komment: A legjobb ha még magyarázni sem kell
-----------------------

Refactoring elõtt és után unit teszteket kell futtatni. Lehetõleg minden lépés után.

6 nagy refaktorálási kategória:

Composing methods: Metódusban való módosítás
Moving feature between objects
Organizing data
Simplifying Conditiona Expressions: Bonyolult ife-ek szétszedése
Making Method Calls Simplifier: Jól használható interfészek készítése
Dealing with Generalization: pl.: Extract super class, pull up, push down
-----------------------

Extraxt vs. Inline method() ki, és vissza szervezés (a metódus törzsét visszarakjuk a hívás helyére ).


-----------------------
