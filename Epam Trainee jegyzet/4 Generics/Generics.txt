Java 5-tõl, akárcsak a varargs és Iterable interfész. 
Java 7tõl lehet elhagyni az egyenlõség jobb oldalám álló collection gyémánt operátorából a típust.

Mire jó? - Hogy úgy írjunk kódot hogy az típusfüggetlen legyen.
Csináljunk egy házat, azután mondjuk meg hogy az milyen (Családiház, kutyaol, madáretetõ).
Osztály szintü (interfészek is)
	A típust változóként adjuk meg.
Metódus szintû
	A paramétereket adjuk meg vele.
		pl.: add method(lehet String, int, ..)

A generic segítségével fordítás idejü hibává tudjuk alakítani azt, ami elõtte futás idejû volt, mert hát egy sima arrayList-be bármit belengedett tenni, kivételkor meg csak néztünk.

TypeErasure: Csak egy osztály file jön létre, nem pedig típusonként különbözõ(ellentéctben C++). 
A generikus szintaxis eltávolítása a kódbol azért hogy visszafele kopmatibilitást biztosítson, helyette kasztolást tesz be.

foreach(tudom a listámról h benne csak pl.:Stringek vannak így meghívhatom az iterátorát)

foreach ben nem lehet concurrent modification kivétel nélkül kivenni elemet a collection-bõl, mert minidig nézi egy számlálóból hogy történt-e módosítás és ha az a számláló nem egyenlõ a sajátjával, akkor dobja ezt a hibát.
Nem kell több szál h concurrent modification exceptiont kapjunk.
Viszont ha mi csinálunk egy saját iterátort és azzal remove()-oljuk az adott elemet, akkor nem lesz concurrent modification.
modificationCount, ez egy int mezõ, azt számolja h hányszor módosították már ezt az int mezõt.
Az iterátor elviszi magával azt hogy mennyi a módosítás számláló értéke 
és minden egyes lépésben amikor hívják rajta  anext()-et összehasonlítja hogy a collection jelenlegi módosítás számlálója
egyezik-e azzal ami nála van, mert ha nem akkor valaki átírta alatta. 
foreach() - concurrent modification exc. Egy szálon is el lehet követni.
Az iterátorral ki lehet törölni viszont elemet.

Autóboxing az nem kasztolás, hanem átalakítás(konverzió) a primitívbõl a wrapper osztályának segítségével referencia típussá és fordítva.

A kasztolás primitív számtípusok közötti konverziók (megengedõbb esetén elhagyható, szûkebb estén kötelezõ a típuskényszerítés (long->int)), 
vagy a referencia és referencia között (Objectrõl->String ha azt tudom h az, mert mondjuk instanceof operátorral megnéztem.)

Azt hívom generikus metódusnak aminek saját típus paramétere van.
Azért hasznos a generikus metódus hogy ne kelljen sok különbözõ túlterhelt változatot írni.

<A típus paraméter értéke akkor kell kitenni ha a paraméter érték(ek) egyezik(nek), különben az osztályét kapja> visszatérésTípusa metódusNeve(paraméterei){}

A tömbök viszik magukkal a típusaikat és ha egy Integer[] tömbre rámutat egy Number[], majd ezen keresztül double értéket akarunk beletenni, akkor az ArrayStoreException lesz.
A Number[] õse az Integer[]-nek, mint a Number az Integer-nek, de List<Number> már nem õse List<Integer> -nek

<?> számunkra ismeretlen, de konkrét típus, ennek a joker karakternek az elkapása és helyettesítése egy konréttal (<T>) a wildcard capture

<? extends T> = vagy az õsítpus vagy annak valamely leszármazottja.

Valójában <?> = <? extends object> Shorthand.

List<?>  != List<Object>

List<?> aList = new List<Integer>(); OK

List<Object> aList = new List<Integer>(); NEM OK!  Nagy különbség a tömbökhöz képest.

<? super> konkrétan az, vagy valmelyik õse. Kontra variant subtyping 

super, extends, <?> = wildecard bounds  a neve.

A kényelem miatt lettek bevezetve (Ne kelljen mindig kasztolgatni, foreach használható legyen, autoboxing),
illetve a típusbiztonság miatt.
A compiler belegenerálja a kódba helyettem a kasztolást, a lényeg h el van rejtve elõlem.

A tömbök is referencia értékek, mögöttük is áll egy típus. 

Java típus rendszer: primitív típus (egyszeri mindennapi mûveletek elvégézésére, 
a == érték szerint értendõ), referencia típus: Osztály, interfész, metódusaik vannak (az == referencia szerint értendõ)

Referencia típusok: (Osztály, Interfész) ezek objektumok. Õs és leszármazottak között hierarchiát építhetünk fel.
Egy interfésznek több õse is lehet.   

Absztrakt osztály és interfész hasonlóság: Egyiket sem lehet példányosítani.

A super nem a közvetlen õsten lévõ metódust hívja meg, hanem elkezd felfelé ballagni és az elsõ találot.

A tömbökhöz tartotó osztályok is hierarchiában állnak.

Minden tömböt osztály ábrázol. 

Type erasure:
https://docs.oracle.com/javase/tutorial/java/generics/genTypes.html

Mibõl											Mi

public class Node<T>{}							Node 

private T data;									private Object data;
	
private Node<T> next;							private Node next;

public Node(T data, Node<T> next){}				public Node(Object data, Node next) {}

public T getData() { return data; }			 	public Object getData() { return data; }
 
--------

Mibõl											Mi

public class Node<T extends Comparable<T>>{}	public class Node {}

private T data;									private Comparable data;

private Node<T> next;							private Node next;

public Node(T data, Node<T> next){}				public Node(Comparable data, Node next) {}

public T getData() { return data; }				public Comparable getData() { return data; }

				
	












 










