IP-cím: 4 ponntal elválasztott szám.
	Vagy az oprendszer oldja fel (onmaga is tárolhat mások számára)
	Vagy máshoz fordul (Szolgáltatóhoz fordul DNS-Domain Name Serever)
	
Get kérésünket a szerver oldal feldolgozza.

Erre kapunk HTTP választ. Nem feltétlenül HTML-t kapunk vissza.

Applikációs protokollok (Adatok átjuttatására):
	HTTP, FTP, POP3
	
Átviteli protokoll:
		TCP: kapcsolat alapú (elmegy-visszaigazolásra kerül-megfelelõ sorrendben)
		UDP: csomagkapcsolt-mindegy milyen sorrendben érnek oda. Vagy hogy oda ér-e az se érdekel.
		RealTimeProtokoll (Skype -az h esetleg kiesett 1-2 másodõer kiesett nem baj, de ne legyen csúszás)

Hálózati réteg
	IPv4 :elfogytak az ip címek
	Ipv6
	
Két eszköz közti adatátvitel
	ADP, MAC
	
A HTTP fejlécében van arra információ hogy mit tarlamaz.
	TCP/IP-re alapuló protokoll.
	
HTML XML-eseítve = XHTML <->ellenszabvány: HTML 5 (2007) Szabványgyûjtemény. Browserek implementálják.
	A Browser platformmá avanzsálódott elõ.
	
URN: Unified Resource Name	
	deprecated

URI: Unified Resource Identifier
	Ennek részhalamaza az URL:
	
HTTP protokoll: Kérés<->Válasz alapú kommonukáció. Az adat flow egyirányú.
	Elvileg szabad szemmel olvasható.
		Kérés (Kliens: aki kérést össze tud állítani)
			Fejléc (map): Tömörítés, sütik, biztonság
		Válasz (Szerver: bárki aki a kérésre választ tud adni)
		
Webszerver: HTTP-n kommunikál, kérésre ad egy választ, semmi komolyat nem csinál.

Servlet konténer(TomCat): kisebb, kevesebb erõforrást igényel mint az alkalmazásszerver.

Alkalmazásszerver: Bonyolult erõforráskezelés, plusz biztonság, EJB kezelés.
	GlassFish, WebSphere, JBoss
	
Szintaktika:	
	GET:path?key=valu&key=valu&..ProtocolVersion
	Host: akihez fodulunk
	Request headers: mi mit fogadunk el válasznak.

	Response:
	Protokoll version, válasz status code, content-type, body
	ContentType: meghatározzuk h milyen típusban válaszolunk.
	
	HEAD: Rész információkat ki lehet szedni: mikor módosult utoljára az oldal (cache-elés)
	
Sütik: 
Kulcs-érték párok
	Általában a szerver hozza létre h a kliens oldalon bizonyos adatokat tároljon. Kezdetleges Session.
	Tudom h a kliens hol tart, nem nekem kell mindnekit számon tartanom.
	A kliens minden egyes sütit mindig visszaküld a szervernek válogatás nélkül. (Tudja h mi van a kosaramban.)
	Mindne sütinek van lejárati ideje. (Múltbéli adatot állít be, s a borwser kiüríti)
	Mostmár csak domaincímeken belül lehet a sütiket felhasználni.
	Sütiben jelszót nem szabad(, de lehet) tárolni. ID-val eltárolni szerver oldalon a felhasználó nevet/jelszót s azt visszaküldeni sütiként.
		Ellophatják, s bejelenetkezhetnek vele, de a jelszavunkat magát nem fogják tudni.

HTTP servers:		
	Apache: //A-patchy
		htdocs: resource folder
	
URL Encoding: Nem megengedhetõ pl: a szóköz. %escape-elni kell.

AJAX: Háttérkommunikáció a szerverrel kliens oldalon. Nem csak akkor amikor frrisül az oldal.
	Asnychronous JavaScript and XML. -> Inkább AJAJ(ason)

<script src="myScript.js"></script>   //Ezt így kell hogy meg is csinálja. </> esetén lefordul de ne nem csinál semmit.

JS: nem objektum orientált, hanem funkcionális nyelv.

Node.js :Szerveroldali JS.

FrameWork: miért jók? Megoldja a problémákat helyettünk, megoldások lehetnek szabványokra.

JS: Dom manipulációkra.
	Framework-ök:
		JQuery: Elemek megkeresése, CSS manipulációra
			Erre épül az Angular.js
	
	Jellemzõen a file vége felé töltünk be:
	
	
Single page application(SPA): Egyszere töltõdik az oldal, onnantól kezdve JS majd oldjon meg mindent. Kliens oldalon van a teljes készlet.

JSON: Jobban átlátható, de hogy kisebb az biztos. Van hozzá Json séma is.

WebServices: Kommunikáció szerver és kliens között.
	SOAP: Simple Object Acces Protokoll. mit tehetünk bele -> WSDL: Web Service Definition Language
		Körülményes és sok a felesleges információ.
		
Rest (Representational State Transfer)
	archytecturális stílus megszorításokkal:
		Az adatok és a funkcióik egyedi azonosítók mentén érhetoek el.
		Request<->Response based.
		Állapotmentes kommonukáció.
			Minden kérés tárolja az összes információt, nincs context tárolva a server oldalán.
			Nincsenek állapotok. Egy interfészen keresztül elérhetõ egy szolgáltaltás a szerveren.
			Állapotok közötti átmenetekben gondolkodunk, nem akarunk állapotot tárolni, mindig csak egy átmenetet fog ellátni.
			Könnyebb a terhelés megoszlás mert bármelyik kérés bárhova beeshet.
			GET,PUT,POST,DELETE
		Layers
	
Servlet: Egy pici szerver: kis kód amihez beesik a kérés és rajta múlik h milyen választ generál majd. Lehet xml, json, weblap, bármi.
	Gyakori megoldás hogy elõl van egy szervlet ami satikus tartalmakat szolgáltat és mögötte egy szervlet konténer => jobb performanica.
		Servlet konténer:
			life-cycle menedzser
			szálkezelés: minden hívás külön kezelõdik.
		Dekleratív biztonsági protokollok (inkább Spring security-t használjunk)
		A legtöbb konténerben van JSP support (TomCat) Jasper(JSP engine, ami generálja JSP-bõl a Java source-ot.)
		Cataline(Õ a szervlet konténer). Jetty ilyet nem tud.
		JSP a servlet konténer segítségével java kódra fordul (ezért kell a TomCat-nek a jdk) aminek a végén lesz egy tényleges servlet.
	
		PrintWriter: A válasz testét tölti ki.

A TomCat osztály hierarchiájában a Web-Ink kintrõl nem érhetõ el semmilyen módon, csak ha valami servlet elõbányássza nekünk, vagy valami resource/locator hasonló gfv.

JSP:
	<%=new java.util.Date() %> így adunk meg java kódot. 
	A JSP-bõl keletkezik egy servlet forráskód.
	
	
	Ne itt írogassunk kódot, hanem a servletben.

	
MVC (Fõ cél: a megjelenítést és a modellt szétválasztani.): 
	View: Jelenítse meg az adatot valahogy (html-t vagy pdf-t mindegy)
	Controller: Ide esik be a kérés, az üzleti logikáért és a koordinációért felelõs. Átadja módosítások után a view-nak a vezérlést.
	
	Servlet Life-Cycle:
		Amikor elõször hívják akkor a szerver betölti magát az osztályt.
		Ez után létrehozunk egy példányt egy konstruktorral.
		Inicializálunk.
		Átkerül a kész állapotba és megkapja a hívást/okat. Minden kérés külön thread-en kerül kiszolgálásra.
		Megsemmisítésre kerül a példány. Bármikor megsemmisülhet a szerver által, ha már nem érzi szükségességét (maga után feltakarít).
		
		Ha új osztály kerül be, megnézi h van-e már ilyen, 
			ha igen, megnézi h használja e valaki és az majd csak a következõ kérés során fog hozzájutni az új osztályból született példányhoz.
			Törli a régi classt
		
		Minden egyes híváshoz új thread indul.
		
		Hívások között õrízhetünk adatot (session)
		
		Servlet a service metóduson keresztül érünk el dolgokat. Ebbõl származik le httpService()
		
		Minden Servletnek lehet egyedi konfigja
		
		ServletContext(Application context)-en keresztül a servlet konténert szólítjuk meg hogy aki szétdobálja a kéréseket az egyes felek között, vagy elõássa a fileokat.
	
		<servlet>
			<servlet-name>name</servlet-name>
			<servlet-class>class</servlet-class>
			<load-on-startup>1</load-on-startup>	//bármilyen száám nagyobb mint egy ->autómatikusan betöltõdik, nem kell várni míg oda elnavigálunk
		</servlet>
	
	Init paraméter megadása servlet-nek:
		web.xml	
			<init-param>
				<param-name>servletInitParam</param-name>
				<param-value>init parameter for the servlet only</param-value>
			<init-param>
	
		servlet.java	
			String initParam=getServletConfig().getInitParamter("servletInitParam");
			
	Init paraméter megadása context-nek:
		web.xml	
			<context-param>
				<param-name>contextInitParam</param-name>
				<param-value>context parameter for the whole context</param-value>
			<context-param>
	
		servlet.java	
			String initParam=getServletContext().getInitParamter("contextInitParam");
	
Attributumok (összegyûjtött adat):
	Miután beletettük a scope-okba és a hívás véget ért ezek el is vesznek.
	Nem mindegyh milyen adatot melyik scope-ba teszem. Karbantarthatóság miatt és nagyon fel is duzzadhat egy session

Scopeok:
		3 alapvetõ jellemzõjük: 
			Név
			Elérhetõség (honnan érhetõek el. Különbözõ servletek scopje-egymásból nem érhetõ el (legalábbis nem kéne))
			Élettartam (life-span)
			
			Context: Application scope
			Request: A requesttõl indul és miután vissza lett küldve minden ami benne volt kitörlõdik.
				Belõle szedjük ki a paramétereket és ide rakjuk vissza az adatokat amiket összeszedtünk és meg szeretnénk jeleníteni.
	
Session:
	Timeout-ot meghatározhatunk:
		A szerver konfigurációjában
		web-xml-ben is
		A kliens jegyzi meg a Session id-ját.
	
	
	
Requestben is érkezhetnek rejtett paramétereket

	Get esetén csak az url-ben tudnak menni paraméterek, amit szeretnénk elkerülni.
		Könyvjelzozheto
		Idempotens
	Post: paraméterek már a body-ban is mehetnek.
		Nem könyvjelzozheto.
		Nem idempotens
	
Idempotens: Hátsó állapotot nem változtatok. (Többször lefuttatom ugyanezt kapom.)

Redirect:
	SendRedirect(): elérjük a kliensnél h a kérés menjen át egy másik oldalra. 
		Új URL keletkezik, mintha rányomott volna egy új linkre. (302-es kód)
	
	RequestDispatcher: 
					Vagy tényleg átkerül (forward) (Invisible for the client- nem látja az url-ben hogy át lett irányítva)
					Hozzáteszek valamihez amit én kaptam. (include)
					
					
A JSP(view) a megjelenítésért felejen és a requesten keresztül érje el a servlettõl a szükséges adatokat, ne a kontextusból bányássza ki.

A ContextInicializálása is egy elkapható esemény, amire feliratkozhatunk.

SessionManagement:
	Autentikáció-bekerül egy user object a rendszerbe. Az vagy-e aki?
	Authorizáció: Megmondja h ki mihez férhet hozzá.
	
	Hol tárolhatunk session adatokat: db, text file (legyen perzisztens). StatefullEnterprise JavaBean-ben.
		HTTP Session: Van lejárati ideje, de meg is szûntethetõ (leáll a gép)
		
		Egymás session-jébe nem hallgathatunk bele.
			Session hijacking.
			Session id sütiben tárolódik.
			
			getSession: van lehetõség h ne feltétlen csináljon ha eddig nem volt.
			
			Ha nincs süti akkor is átjuttatható a sessionId.
				A könyvjelzõbe is bekerûlhet sessionId.
		
	Szálbiztonság:
		Ne használjunk tagváltozókat, vagy akkor szinkronizáljuk õket.
		Requestenként külön szál indul, nem kell erre figyelni ezért.
		
	A session-öket el kell pusztítani, különben úgy járunk mint a windows registry mindenki beleír, de maga után már nem töröl.
		Szerver oldalon történjen a menedzselés
			Lejárati idõt a múltba tesszük.
			Lejárati idot percben adjuk meg.
	
	Bejelentkezés után csináljunk új session-t és abba pakoljuk át azokat az adatokat amikkel addig oda értünk. Biztonság-hijacking
		Addig nem volt tikosított.
		
	Terheléseloszlás:
		session vándoroltatás: költséges. 
		
	A session-ök attribútumainak serializálhatónak kell lenniük.

Session vs Login vs Remember me:
	Session: Kliens specifikus informáiók tárolása requestek között.
	Login: User információinak átadása a session-nek.
	Remember me: Auto-login miután a session lejárt.
		Megoláds: a server küld egy long-livin cookie-t egy egyedi azonosítóval. 
	
	
Sütik kezelése:
	sec az alapértelmezett élettartam mérték, ezt szorozgassuk 60-nal.
	Név-érték párral hozzuk létre.
	
Remember me:
	Emlékezzünk rá h a browserrõl már bejelentkezett.
	Kvázi autó login a user nevében.
	Hosszú életû süti elkészítése.
	
A JSP tulajdonképp egy servlet, a kódját generáljuk. Arre törekszünk h csak a megvalósításért legyen felelõs.
	expresssion:
		<%=...%>
	declaration:
		<%!...%>
	comment:
		<%--...--%> nem kerül be a generált kódba.
		<!--...--> HTML kommentként létrejön
	direktívák (karakterkdolás, kifejezések kiértékelésének letiltása)
		<%@...%>

	import: osztályt tölt be
	include: a célként megadott file-t bemásolja az adott helyrõl
		Kiszervezni jsp-részeket (fejléc/lábléc)
		A Header-t be lehet hívni include-dal
		
PageContext
	Újabb scope (//mik vannak még: application, session, request)
	Csak erre az oldara vonatkozik.
		find attribute tudja h hol keressen a scope.ok között. //Nekünk is tudnunk kéne

web.xml-be tegyük be a JSP-ken történõ scriptelés elkerülése végett(újra kell indítani):
	<jsp-config>
	<scripting-invalid>true</scripting-invalid>
	</jsp-config>
	
Bean-ek: a JavaBean specifikációknak meg kell felelniük
		Kell hogy legyen default konstruktoruk is.
			Vagy nem definiálunk neki vagy ha már van akkor kell hogy mi definiáljunk egy ilyet is.
	
Expression language:
	Read only.
	public static metódusok meghívása.
	Csak bean-ek, vagy map ekre lehet "."-tal ráhívni.
	IaELIgnored 1.7-es TomCat-tõl kezdve false defaultként.
	Többszörös pontozással vigyázni kell. (ezek a getterek, setterek nincsenek, mert Read Only)
	Keresési sorrend:
		Tag(senki nem hivatkozhat rá kívülrõl, kicsit csalás)
		Page
		Request
		Session
		Application
	Nem csak ponttal, szögletes zárójellel is hivatkozhatunk tömbökre, listákra(?)
	Hiba esetén nem ír ki semmit.
	tld=TagLibDirectory (funkció gyûjtemény) be kell regisztrálni
		Nem a szkriptben és nem kifejezésnyelvben kell zsonglõrködni.
		Ez egy leíró amihez valamilyen java code tartozik a háttérben.
		
	Bean: Meg kell felelniük a konvencióknak (paraméterek nélküli konstruktor, getter-setter naming convention)

JSTL: JSP Standard Tag Library
	pom-ba be kel húzni
	uri-ban azonosítani kell

	c:url a sütik kezelését meg tudja oldani ha azok ki vannak kapcsolva(waaat?)
	
	Custom tags:
		Classic tag handler: depricated
		Simple tag handler: könnyebb, scripteket nem igazán lehet használni
		tag files != tld file
			.tag kiterjesztés.
			A tld-nél egyszerûbbek, kvázi JSP-k
			Ez egy statikus include
			c:param, jsp param játszik.
			Dynamic attributes: like varags. key-value párokkal szedhetõek ki.
		tag handler: felhasználható az EL teljes eszköztára
	
	<body-content>...</body-content>
		empty: nem lehet törzse! Nem ugyanaz mint az üres törzs
		scriptless: scripteket nem használhatunk (%-jellel nem kezdõdhetnek, de EL lehet)
		tagdependent: nem lehet EL-lel sem élni
		JSP: bármit lehet
	
Error Handling:
	web.xml-ben szûrjük le.
	c:catch (mintha try blokk lenne lenne és egy catch változóba beletesszük a keletkezett kivételt)
	

Deployolás:
	web-inf: ide kerülnek amiket kívülrõl nem akarunk látni. Egy JSP elõ tud azokból bányászni és meg tudja mutatni, csak direktbe nem érhetõ el kívülrõl.
	Formátumok
		jar- Gyakorlatilag egy sima zip. Átnevezheted és kicsomagolhatod.
		war: webes alklamzás. Elvileg hordozható a szerverek közt, gyakorlatilag nem.
		ear: enterprise jar. Több webes modult is magában foglalhat. Több ear-t, jött jar.
	web-infen belül lakik a claseses: a lefordított bytecode-ot tartalmazza.
	maven scope-jában megadott függõséget nem kell becsomagolni a fileokba, feleslegesen ne vigyük magunkkal ha már ott is van.
	Amit a web-apps alkönyvtárban teszünk azt a TomCat értelmezi autómatikusan
	
Statikus erõforrások, s elérhetõségük:
	Fielok pl.:
		.js
		.css
		képek
	Ezeket mappelni kell. Nem feltétlen kell korellálnia a file rendszerrel az uri nak. 
		Természetesen a legspecifikusabb érvényesül.

Biztonság:
	Data Confidentiality: illetéktelenek ne tudják olvasni
	Data Integrity: Senki ne tudjon belenyúlni anélkül hogy mi azt látnánk (Digitális aláírás, fel tudom fedezni ha beleírtak)
	
	realm: értelmezési tartomány/konfiguráció. Kinek-mihez van jogosultsága (adatbázisban, LDAP(központi nyílvántartás))
		Memóriában tárolt: TomCat users
		Nem resource-ra hanem kollekcióra adunk jogosultságot (url-patternek)
		Autentikációs metódusok:
			Basic kódolás vs titkosítás
			FORM: HTTPS
				Az autentikáció után az információ a session-ben lesz
			Digest: HTTP standard: szerveroldalon van az adat, ez már titkosított, nem igazán használják
			Client-Cert: EE standard (pl ssh kulcs) az ügyfélnél van beregisztrálva egy certificate(kulcs), azzal azonosítja magát. HTTPS nélkül is használható.
		Transport(adatátvitel)
			Integral:
		HTTPS: HTTP over SSL(Secret Socket Layer)/TLS: Létesít egy teljesen biztonságos csatornát a két fél közé, ezen sima HTTP üzenetek mennek keresztül
			Általában nyílt forráskódú titkosítás.
		
			
Filters:
	A filterek a servlet API AOP része(?) //A CSS volt a HTTP AOP-ja
	A kérés beeseik a konténerbe, onnan a filtereken keresztül a servlethez
	A kérés és a válasz a filteren keresztül megy. Itt a filteren keresztül bármit megtehetünk.
		Kódolás megváltoztatása, logolása
	A filterek a deklarálás sorrendjében állnak sorba és futnak le
		Filter interfészt meg kell valósítania.
			Tovább kell hívnia a következõ filterre (FilterChain)
	Meg kell addni egy URLpattern-nel vagy servlet névvel h melyik filter vonatkozzon rá
	
SOP: Single Origin Principle: Egy script csak egy adott domain-en belül garázdálkodjon.
	

Kérdések:
	Amiket nem tudtam:
	
		valami kötelezo része: nem a method hanem a version a helyes
		
		A feladatból hiányzik a doPost method
		
		A view nem férhet hozzá a persisted objecthez, csak a datához
		
		Nem kell szinkronizálni a metódusokra, alaból minden új thread-en jön létre, szóval nem a context a biztonságos tárolás többszálsúság esetén.
		
		Nem kell implicite megadni semmilyen példányosítást, az out-ot alapból használhatjuk.
		
		Szinkronizációs probléma a requestek esetén nem alakulhat ki.
		
		A forwardnál a leghoszabb a helyes válasz.
		
		Nem lehet a web-inf et elérni csak resource fgv-en keresztül
		
	Amit tudtam:
	
		A session megszunik autómatikusan ido elteltével, nem kell folyamatosan újra lekérni.
		
		JSP-n az Tag library-t a legrövidebb válasszal tudjuk bekérni.
		
		ServletConfig a servlethez init paramétereihez fér hozzá. A serletContext pedig applikáció szintu.
		
		Exception esetén akár saját származású "hibaelismero" oldalt is tudunk adni a usernek
		
		
		
		
		