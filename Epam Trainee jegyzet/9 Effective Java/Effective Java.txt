Static factor method

Cél: Kliens kódot segíti egy példányhoz juttatni. Konstruktorok mellett vagy helyett.
Nem egyenlõ a factory patternnel.

Ellentétben a konstruktorral: Van neve. Különbözõ szementikát adhatsz ugyanazzal a szingnatúrával rendelkezõ függvénynek.
Nem kötelezõ hogy új példányt visszadjon. Ilyenkor mûködik az ==, mivel nem jön létre új példány, s így nem szlükséges az equals.

Visszadhat subtype-ot is.

Paraméter dedukció: Nem kell megadni a genereikus típust diamond operátorban, mert kitalálja. Java 7-tõl már elhagyhatók a <>;
Hátránya lehet h mivel nem különböznek a szignatúrák ezért javadocban kell megírni h melyik mire való.
További hátrány hogy ha nincs publikus konstruktor, akkor nem lehet örökölni abból az osztályból. Ilyenkor kompozíciót lehet használni.
---------------------------

Builder: 

Amikor egy objektumnak sok fieldje van és nem akarjuk azokat konstruktoról állítgatni, létrehozni sok skülönbözõ konstruktort.
Helyette:

Constructor telescoping: Nyúlik az egymást hívó konstruktorláncolat.

---------------------------

Java Bean:

Olyan klasszból származó objektumok amiknek van egy paraméter nélküli default konstruktora és setterekkel lehet állítgani a fieldeket.
Dummy pojo.
Probléma: inkonzisztens állapotban lehet mert egymás után következnek a setterek.

Elõször létrehozok egy buildert, majd azon lácba beállítom az értékeket, majd utolsó elemként lezárásként rárakom a build()-et.
A public build meghívja a privát konstruktor(builder) aminek átadja a buildert. A builderbõl kimásolódnak az adatok lokális változókba
azért hogy azon keresztül késõbb ne tudjunk módosításokat végrehajtani. Utána ezeken a lokási változókon végezhetünk chech-k eket és úgy kapnak az objektum final fieldjei értéket.

---------------------------

Objektumok újrafelhasználása:

Integer-nél a valueOf cash-el (-128 : +127), adatbázisok vonnection poolokat használnak. aZ executorok thread poolokat használnak.
  
---------------------------

Elimináljuk felesleges objektumokt.

Loitering: Akaratlan referencia visszatartás: amikor pl.: nem töröljük ki az elelemket egy collection már nem használt részeirõl.
Garbage collector nem tudja felszabadítani, mert van rájuk referencia, csak kliens szemszögbõl már nem láthatók. 

WeakHashMap: takarítás seígtõ akárcsak a Timer/Scheduled, már nem használt adatok törlésére szolgálnak a cash-bõl.

Swing: Lekötni a listenerekt ha már nem használjuk, ezzel is fel lehet venni a harcot a memoryleak-kel.

---------------------------

Kerüljük a finalizereket:

Ha az objektumra már nincs referencia akkor a kipucolés elõtt a GC meghívja ezt a metódust. Ez felvet több problámát:
Lesz-e ilyen alkalom? Mi kerülne amúgy egy ilyen kódba? -Erõforrrás, memória felszabadítás. (használjunk try with resources-t)
Attól mert már nem mutat senki az objektumra még nem biztos h a GC abban a pillanatban, rögtön fel is szabadítja.
A GC futása nem determinisztikus.

---------------------------

Object közös függvényei:

equals(): (Alapból) Egy objektum csak és kizárólag önmagával "egyenlõ". Enumok esetében lehet "==" -t használni.
	Reflexiv: egy adott példány minidig ekvivalens önmagával.
	Szimmetrikus: Ha egyik példány ekvivalens a másikkal, akkor a másik is az egyikkel.
	Tranzitív: Adott három példány: ha ez elsõ kettõ equals, illetve a máodik és harmadik is equlas, akkor az elsõ és a harmadik is equals.
	Legyenkonzisztens: Egy java program futása során akárhányszor hívom meg az x.equals(y)-t mindig ugyanazt az eredményt adja vissza, akkor is ha késõbb meghívom. Tehát legyen konzisztens.
	.equals(null): minidig fals-t adjon vissza. Ha x null akkor nullPointerException-t fogok visszakapni, mert null-on nem lehet meghívni semmit.
	
	(Object o).t kell átvenni, ha más típusú szerepel a szignatúrában az nem overrideing, hanem overloading.
	
	Liskov féle helyettesítés: A leszármazottnak felhasználhatónak kell lennie az õséenek helyein. Ilyenkor viszont az equals-nak is mûködnie kellene.
	Megoldás: használjunk az öröklõdés helyett kompozíciót és kérjük le a "szülõ objektumokat" és azokat hasonlítsuk össze, majd saját magunkat a másikkal.
	


hasCode(): A típusunk adott példányából számol egy integer értéket, azért hogy hash-elés használó adatszerkezetekkel lehessen használni a mi típusunkat.
		A hash() fgv akkor jó, ha egyenletesen szól a kosarak között. A kosárban már az equals()-szal történik a hasonlítás.
		A diszkrét számú kosarak mögött láncolt listákba kerülnek aza objektumok.
		
		Legyen konzisztens: alkalmazás futásonként minidg ugyanazt az értéket produkálja. (ha valamilyen adatja megváltozik akkor más equals keltkezik, futásonként)
		
		Ha két objektum equals() akkor a has()-eik is egyenlõek. Visszafele nem kötelezõek. Csak annyit jelelnt hogy ugyanabban a láncolt listában vannak amire a közös hash() mutat.
		
		A hashcode-ot az objektum fieldjeibõl számoljuk, ebbõl következik h immutable objektumok esetén az õ hash-üket el lehe cach-elni.

toString(): guava-nak van egy Object.toStringHelper(this) metódusa, ami gyakorlatilag egy builder és azon láncba hívva az add("") metódusaokat és végül lezárva egy .toString()-gel 
		könnyebben kezelhetõvé teszi a sok paraméteres default-override-olt toString()-et.

		Másik megoldás: String.format(): Jól definiálni kell javaDoc-ban h mi lesz a mi API-nkban a formátum. Hátránya h ezután cipelni kell magunkkal a következõ verziókban.
		
		Közép út: Nincs megkötött formátum, de éreztetjük hogy kéne.

		
clone():

finalize():

---------------------------

Comparable interface: rendezési problémákat oldhat meg különbözõ típusokra.
		Comparable <T> típust vár paraméterül és int-et ad vissza.
		{int compareTo(T t)};
		Negatívot, ha mi kisebbek vagyunk mint õ, nullát ha egyenlõek(ajánlott hogy equals szerint is), pozitívot ha mi nagyobbak vagyunk mint õ.
		
		
		
Comparator interface: jó volna ha az adott típust tudnánk rendezni, de nem férünk hozzá az adott típus implementációjához.
		compare(T t); eldönti h melyik a kisebb, melyik a nagyobb

		
		//guavában: ComparisonChain.start().compare().compare.result();
		
---------------------------		

Exceptions: Karbantarthatóságot, megbízhatóságot, olvashatóságot tud növelni.