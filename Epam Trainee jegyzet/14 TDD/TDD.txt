Topic:
	Milyen minõségi változásokat hoz a kódra, ha már elõre megírjuk a teszteket?

	Minden egyes szoftver egyedi (Tesztelés nehézségei):
		Ami minden fejlesztõ számára új: Application domain (az adott terület szaknyelve)
		Új technológiák a saját szakmánkban.
		A csapat amelyben dolgozunk.
		
A fejlesztés az tanulási folyamat: Az új belépõnek meg kell ismernie a projektet.
	
Iteratív fejlesztés(Nincs céldátum). 
	Az iteratív fejlesztés hátrnya hogy abszolút nem használható produkt jöhet létre (vagy menet közben), 
		ha nem sikerül betartani a feltételeket(idõ, pénz).
	Minõségi problémákat nem feltétlen ismerjük meg menet közben, csak a végén (csúszások).
	
Inkrementális fejlesztés:
	Amikor valami minimálisat elkészítünk az már használható és késõbb igény szerint bõvíthetõ, további elemeket hozzá lehet adni.
	Folyamatos leszállítás, feedback<-visszacsatolás (Minõségi ellenõrzés)
	
TDD: az iteratív és az inkrementális fejlesztés ötletén alapul:
	Ezt a lépéssorozatot kell újra és újra imsételgetni:
		1,A munkát egy olyan teszt megírásával kezdjük ami el fog failelni. (Elõre definiáljuk a measurable goalt.)
		2,Írunk egy implementációt, ami ezt a tesztet kielégíti. (A lehetõ legkevesebb munkára szorítkozzunk.)
		3, A kód minõségét javítjuk refactoringgal. (A teszt már zöld, az átalakítások során is annak kell maradnia.)

Tesztírási elvek:
	Mire kell figyelni?
		Teszt metódus szerkezete:
			//Given
				Adott feltételek mellett elõkészítünk objektumokat.
				* egy üres sor legyen közöttük *
	
			//When
				Végrehajtjuk azokat a mûveleteket amelyek a tesztelt objektumra vonatkoznak.
				
			//Then
				Az elvárásoknak történt-e amit szeretnénk
				
		Ennek a háromnak a közös neve: Arrange Act Assort //Elõfeltétel, Mûvelet, Eredmény
		
	A teszt metódus elnevezése: Adott egy elvárás amit valamilyen feltétel teljesülése esetén szeretnénk.
	public void notifyObservers_when_valueChanges()
				okozat_akkorha_ok
				cél_akkorha_valamiMegváltozik
		A test v should felesleges. Az a lényeg h mi az amit elvárunk.
		
	A teszt osztály vene: TesztelendõOsztályTest
	
 A tesztekra is alkalmaznunk kell a refactoringot.
	
A tisztakód mindig elõrébb van mint a teljesítmény.

A kód lépésrõl lépésre átalakul.

A ToDo lista folyamatosan bõvül, a hibák/problémák/veszélyek feltárásával.

A kód általános, a teszt az konkrét. Adatok kívülrõl jönnek az alkalmazásba, a tesztekben beégethetjük õket.

Regression-visszalépés.

Apró lépésnekben gondolkodunk, így nem eseik visszatérni hozzájuk ha elveszítettük a fókuszt.

A teszt dokumentálja a programot.

A TDD kifejezetten bátorít a refaktoringra.
	
Tisztább lesz az interfész és jobban bezárja az implementáció részleteit a megvalósítás(?) 

Csak annyi implementációt szabad írni ami a unit megvaslósításához kell.

Dependency Injection
	A függõségeket a dependency injection framework adja oda kívülrõl.
	
Stubbing:
	Az objektum szempontjából a stub az egy input, onnan kap valamit. A stub hívásának kell hogy legyen visszatérési értéke.
	Elõre betanított válaszokkal hozunk létre egy
	
Nem kívûnatos design pattern:
	Singleton: nem tudjuk megváltoztatni 
	
Demeter szabály: A tranzitív függésõgek által létrejött metódus hívási láncokat csak több mock létrehozásával lehetne reprezentálni, ami nem helyén való.

A technológiát(megjelenítési,s zerver-kliens kommunikáció, adatbázis, stb..) és az üzleti logikát külön kell választani.

A view nem unit-tesztelhetõ, de a Presentation Model ami implementálja a UI logikát azt már igen(?)

Mit teszteljünk és mit nem?
	Logging?: nem(?)
	Gettere-Setterek: nem
	Hybridek (Tesztelhetõ és nem tesztelhetõ felelõsségek, logikák): Szét kell vágni, és ameilyekt lehet az igen.
	Idõzónák. (Rendszerhívás (System Time), nem tesztelhetõ) ez a problémakör hibrid logikára utal.
	
	
Számosság vizsgálat: Egyse, Egy, Több //Ennyi elég

Paraméterátadásnál minél jobban tipizáljunk

Ne teszteljünk egymástól eltérõ funkciókat.

TestHelper: Teszt metódusokban jelezzük h mit szeretnénk és a helperekben valósítjuk meg alétrehozásokat.
	
A tesztekben ne legyenek if feltételek, logikák.

Acceptance testing:
	A program fut, és valamilyen külsõ interfészen keresztül éri el a programot az acceptance teszt.
	Külsõ minõséget vizsgál, azt csinálja a rendszer amire hivatott.
	
	Ez is TDD-vel megvalósítható.
	
	Míg Unit tesztél minden egyes teszt case-nél újra létrehozza az objektumot, addig Acceptance tesztnél 
	változtások keletkeznek, amik kihatnak a következõ futtatásra. (Resetet kell beiktatni.)






















