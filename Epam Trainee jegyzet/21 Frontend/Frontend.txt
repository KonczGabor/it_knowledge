HTML: HypertextMarkupLanguage
	Nem lineáris ->Hálózat az egész szöveg.
	
DOM: Document Object Model, ez egy API, ezen keresztül módosítja a JavaScript a HTML-t. 

Szemantikus HTML: program által feldolgozható legyen.

JS-ben nincs compile time.

HTML5: Reagál a mostani igényeinkre.
	<head> metaadatok
	
Hight Level Content Structure:
	<!DOCTYPE html>
	<html>
		<head><!--HTML head --></head>
		<body>
			<header></header>
			<main></main>
			<footer></footer>
		<body>
	</html>
	
A Google SEO elsõ sorban a <nav>-ban lévõ elemeket vizsgálja a rangsor megállapítása során.

<section> :szabadon értelmezett logikai blokk.

<aside>: lábjegyzet, kiegészítõ

<div>: terület (blokkszintû): A blokkszintû elemek új sorban kezdõdnek.
<span>: inline: Sorban ûlõ dolgok.

<pre> számít a space, mert amúgy csak egyet tenne be. 

<style> -lal lehet css-t beletenni a html-be. De ne használjuk.

CSS selector gyakorlás: https://flukeout.github.io/

CSS: Cascading Style Sheets: Egymásra lapolódó Stílus Lap (Mégis mi határozza meg az adott elem kinézetét. Szabályok egymásra hatása. Általános->Egyedi, Erõsség)
	rule: szabályegyüttes:
		selector-property-value
		divekre a nevükkel hivatkozunk
		Refereniácra #-gel
		Osztályra .-tal
		Ha valami valamin belül van akkor space-t kell tenni.
		Ha valami és valami akkor konkatenálni kell.
		
	Ugyanolyan erõsség esetén a kéõbb deklarát kerül érvénybe (felülrõl lefelé)
	
	Preferencia Sorrend:
	Inline Style > ID > Pseudo > Attribute > Class > Type > Universal
	
	
Böngészõ hoz magával user agent stylsheet-et az szürke mezõben látszik.
	reset.css (meyerweb.com)
	normalize.css 
	
Ojektum orientált CSS	
	~Legó building Blokk: Közös attribútumok alapján készített sémák.
	
	Sprite: sok kis kép egy nagyképre rá szerkesztve. Módszer: a képet tologatom a lyuk fölött.
		Cél -kommunikáció csökkentése.
		
	additív fényforrás: monitor
	subtraktív: nyomdatechnika: elnyeli CYMK
	
//Színkeresõ: https://coolors.co/820933-d84797-d2fdff-3abeff-26ffe6
	
	em: a környezetéhez vizsonyít egy adott arányban. az "m" a legszélesebb betû
	
//Ikonok: https://icomoon.io/

	Positon Poprties:
		Static: ez a default
		Realtive: elsõre nem történik semmi, de felruházódik egy csomó plusz tulajdonsággal, p.: offset attributes
			Az ereti helyéhez képest lesz relatív. Kutyaház és póráz. Övé a hely, csak eltoltuk.
		Absolute: Nincs interakcióban a flow-val. Haladunk felfele a dom öröklési fában és az elsõ relatív, 
			vagy absolute elementhez képest van viszonyítva. Ha nincs ilyen, akkor a body lesz az.
			Önmagukban is létrehoznak egy új viszonyítási koordináta rendszert.
		Fixed: A léc mindig oda ragad a window egy adott részére.
		Inherit: a szülõtõl örököl
	
	Floating: Körbefolyatás. Az elõzõ elemhet viszonyítunk, ha végeztünk fel kell oldani (clear:left).
		Left
		Right
		Inherit
		None
	
	Boilerplate html5
	
	Modernizer: JS segítségével rávizsgál a böngészõ bizonyos feature-eire.
	
	NoJS: degradációra.
	
	viewport: mobilokra lekezeli a pixelszélességet.
	
	Reszponzivitás: nem csak a képernyõ felbontás, hanem az adott eszköz speciális funkcióinak kihasználása (giroszkóp)
		Mobile first: ha ott megy akkor már könnyebb a többihez igazodni.
		
	Medua Query: "legyen igaz akkor ha:"

	JS
		shortInt, Integer, Bigint, Float, Double
		A function-ök objektumok.
	
	Hártány: Globális változók.
	
	Case sensitive
	A báltozóknak betûvel kell kezdõdniük, vagy alulvonással, vagy $-ral.
	
	NaN nem egyenlõ(==) önmagáával, külön rá kell kérdezni h isNaN?
	
	A switch case ágaiban a Javával ellentétben kifejezéseket is tehetünk.
	
	A for ciklusban deklarált segédváltozók az eégsz functionben láthatóak, nem csak a for blokkjában.
	
	Ha tömbböl törölsz egy elemet, akkor annak a helyén undefinied lesz.
	
	A true, false, null, undefinied nem object.
	
	Objektum: név-érték párokból álló gyûjtemény.
		Egymásba ágyazhatóak.
		Osztálymnetes,
		Nincsenek klasszok.
		Egy objektum egy másik onjektum példánytól örökölhet.
		Minden átadás referenci szerint történik. 
		A prototype-jkával folyamatos kapcsolatban áll az object.
		
		A funkciók objektumok. A function.prototype-ból származnak. Vissza lehet térni velük mint visszatérési érték.
		Egymásba ágyazott function-ök esetén átlátnak egymás scope-jaiba.
		
	Invocation pattern  
	Function  
	Method
	Constructor
	Apply 
		
	Scope: nincs értelme késõbb deklarálni
	
	Closure:
		Az innerfunction hozzáfér a külsõ fgv paramétereihez, változóihoz akkor is ha már a külsõ fgv nem él. Kávzi leg lehet vele vaslósítani a private láthatóságot(?).
			Emiatt lehet modul pattternt szimulálni és a new kulcsszóval kvázi java osztályokat létrehozni.
			Igyekezzünk global objecteket létrehozni.
			
		
		
	Callbacks:
		2 szálon tud csak a JS dolgozni, nincs multithread. Csinálj valamit és majd callback-ben add vissza amíg mi dolgozunk máson.
		
	jQuery:
		JS-el el tudunk érni DOM manipulációt.
		
	NodeJS: alapvetõen egy JS platform. Interpreter, és szinte minde op-ra feltelepíthetõ.
	
	Tsztelésre a Jasmin ajánlott, ugyanúgy unit tesztelendõ, mint a Java alkalmazások.