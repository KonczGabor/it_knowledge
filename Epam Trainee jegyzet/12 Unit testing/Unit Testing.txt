Mi a szoftver tesztelés?
	Egy feltáró folyamat hogy pontos képet kapjunk a szoftvertermékünk minõségével kapcsolatban.

Ennek a vizsgálódási folyatnak objektívek és függetlennek kell lennie.
	Objektív:
		Mindenkinek ugyanazt jelentse. Legyen egy egyértelmû mérték ami a vizsgálódás eredményét, menetét tükrözi.
	Független:
		A tesztek ne függjenek egymástól.
		
A szoftvertesztelés céljai:
	Validáció(Mit csinált a szftover . Lehet-e logolni a rendszerbõl)/Verifikáció(Hogyan csinálta azt ami már tõlem is függ):
		Funkcionális korrektség: lefedi az üzleti követelményeket.
		Technikai korrektség: megvalósítja a technikai követelményeket.
		Funkcionálás: Képes futni/kiszolgálni.
		Észleli és azonosítja a szoftver hibákat.
			
			
Tesztelés attribútumai:
	Scope: minden ami ahhoz kell hogy a metódus lefusson
	Funkcionális (A feature-ök megcsinálják-e amit meg kell)/Nem funkcionális (Minden ami nem a futással közvetlenül kapcsolatos (hány soros fgv-eink vannak.))
	Statikus(Nem fut a kód)/Dinamiks(fut) 
	Verifikáció/Validáció
	
	
Unit tesztelés attribútumai:
	Scope: Bemenet, feauture, paraméterek, minden ami ahhoz kell hogy a metódus lefusson
	Funkcionális: Mert csak azt mondja meg hogy True v False.
	Dinamikus: Fut közben
	Validáció.
		
		
Funkcionális teszt (Mit csinál az alkalmazás miközben fut):
	Unit:
	Integrációs: Több Unit vagy akár nagyobb egység integrálódását vizsgáljuk
	Rendszer: A rendszer egészét vizsgálja egyben.
	System Integráció: Több rendszer együttmúködését vizsgálja.
	Regression: A core feature-ök(legfontosabbak) tesztjét tömöríti. Megbizonyosodok róla h mingid minden jól mûködik.
	Acceptance: Kattingatja a user és megmondja h tényleg így akrta-e.
	Alpha: kis csoport ami jellemzõen belsõ körbõl jön.
	Béta teszt: Jóval nagyobb merítés, széles tesztkör.

Nem funkcionális tesztelés:
	Performance: pl: mennyit vár a user
	Stability: Mennyi ideig tud futni újraindítás nélkül.
	Usability: Elég intuitiv-e a rendszer.
	Security: 
	I18n and localisation: Generealizálni és 
	Destructive: Szándékosan ellehetetlenítjük a futást (adatbázist kilõjjük alóla) és erre milyen választ ad? Illetve azokat visszaállítjuk.
	
	
Unit tesztelés:
	Egy kupac kód(metódus) meghív egy másik típus kódot és megnézi hogy helyesen mûködik e-az. 
	Egy ilyen kupac lehet a unit. Mindez egy framework segítségével. Ebben jött létre, ebben fut.
	Nagyon közel áll a fejlesztéshez. Segít h minél hamarabb kiderüljön a hiba -> költségmegtakarítás.
	Fontos:
		-Easy to implement
		-Runs quickly
		-Runs on push button
		-Anyone can run it
		-Automated and repeatable
		
		
Miért alapvetõek a unit testing framework-ök?
	-közös nevezõ, sok helyen használják
	-olyan struktúrákat és eszközöket biztosít, amivel könnyen tudunk teszteket írni.
	

Mikor kell unit tesztet írni?
	Mikor? Amint kész van egy Class
	Hol? A termék része	(A gyökérben)
	Hogyan? Jól

	
Unit testing framework-ök:
	Mit várunk el tõle?
		Segít abban h könnyedén:
			Írjak egy struktúrát
			Lefuttassak különbözõ elvárások mentén (Reportot kapunk eredményül)
			
			
			
			
Miért jó ha tesztelünk?
	Segíti a jó dizájn/architektúra kialakítását az egyszerû, egyértelmû, karbantarható metódusok kialakításával.

@TEST(expected = RuntimeEcxeption.class) //Megengedi h RuntimeEcxeption kiszökjön a tesztbõl

A JUnit alapból benne van az Eclipse-ben.

A unit teszt metódusok publikusak és a visszatérési értékük void.



Assert: megvizsgáló eszköz hogy a visszatérési érték megegyezik-e az általam elvárttal.
Assertet nem a junit.framework-bõl hanem az org.junit-ból kell importálni. Ez a class statikus metódusokat ad h megvizsgáljak mindenféle értékeket.
Elsõ paraméterként át lehet adni egy Stringet, mint hibaüzenet.
	Assert.assertEquals(expected, actual);	//5, sum(2+3)
	Assert.fail() //Itt mindenképp törjön el a tesztem!
	
Failor: Lefut a metódus, de rossz eredményt ad.
Error: Futás közben error.


Hogyan hozzuk létre a Unit test-et.

	Ugyanolyan névvel, de Test-re végzõdõ osztályt létre kell hozni a test folder alatt.
	@Test annotáció //Rá kell tenni a junit-ot a classpath-ra, nem elég csak importálni.
	A metódusok nevei test-tel kezdõdnek utána tesztelendõ metódus neve, majd a Should és egy olyan szó ami utal arra h mit akarunk visszakérni.
	Kellehet egy példány esetleg underTest néven.
	meghívom a metódust (figyelve h nem a depricated Assertet hívjam, hanem a java, org.junit.)
		Egy tesztmetódus egy dolgot csináljon.
	AssertEquals -nál nem kell mindig elmondani a message-t. Csak akkor írjunk message-t ha tényleg valami hasznosat akarunk átadni.
	
	Hogy ne kelljen minden metódusban külön példényt létrehozni, ezért van egy olyan annotáció h @Before
		Fusson le minden egyes teszt metódus lefutása elõtt.
			@Before
			public void setUp(){
				underTest = new UltimateKnowledge();
			}
Struktúrálni kell a tesztmetódosut:
	//Given
	A helyes érték, speciális inicializálás
	//When (Egyetlen egy darab utasítás)
	A mi tesztünk eredménye
	//THEN
	Tedd ezt, vizsgáld ezt

E legszûkebb assertet használjuk:
	assertEquals(true, result)
	assertTrue(result)	//Ez a szûkebb
	
Kommentelt kódot felejtsük el, úgy kell megírni h önmagáért beszéljen.

NullPointerException-re ne teszteljünk, írjuk meg úgy a kódot úgy hogy az ne fordulhasson elõ <-Defensive programing
	
		
A tesztmetódus nevének When ágában mondjuk el h milyen kondíciók mentén vizsgáljuk. Egy metódusra theát több teszteset is lehetséges.
		
Elnevezési konvenciók:
	Osztály:
		[Class]Test	
	Metódus:
		test[TestedMethod]Should[DoSomething]When[Condition]
	Objektum:
		Konvencionálisan elnevezni (input, result, underTest[-tesztelendõ objektum neve])
		
Minden metódusra legalább egyet, de inkább a döntési pontokhoz (cyclomatic complexity).

Framework:
	Az eclipse plugin feldolgozza a Junit jar eredményeit. (De lehet használni ant-tal, maven-nel. gradle-lal)
	import static org.junit.Assert.*;
	assertEquals(expecte,result); //Ne az outdated-et használjuk.

Az annotációkból lehet többet is létrehozni, tehát egy metódus elõtt több @Before is állhat, de a metódusok 
meghívása kozött a sorrend megtartása nem garantált.
	
Annotációk JUnit-ban:

	private Client underTest;
	@Before
	public void setup(){
		underTest = new Client();
	}
		
	@After
	public void tearDown(){
		system.out.println("nincs, sok értelme")
	}
	
	@BeforeClass
	public static void before(){
		Akkor fut le amikor a class betöltõdik, de még nincs példánya -Statikus inicializálásra való.
		Egyszer fut le.
	}
				
	@AfterClass	
	public static void before(){
		Amikor már minden lefutott, minden kész van akkor hívódik meg. Pl.: Adatbáziskapcsolat megszûntetésére.
		Egyszer fut le.
	}
	
	@Test
	@Ignore	
	Az adott metódust nem hívja meg. Ha több is eltört, akkor a többi kiignore-olom, hogy tudjak azon az egyen dolgozni.
		
	@Test(expected=Exception.class)
	Csak akkor lesz zöld ha kiszökik az adott Exception
	
	@Test(timeout=100) //miliseconds
	Nem igazán unit teszteknél, inkább integritiy teszteknél hasznos. Ennyit vár max, utána piros lesz.
	
	@TearDown:
		Unit tesztben nem gyakori, de integrációs teszben haszos lehet pl.: egy kapcsolat lebontása.
	
Unit tesztben nem írunk programozáis szerkezeteket. (if, swith, for)
	Ha kollekciókon végzek mûveleteket, akkor is csak kézzel töltöm fel.
	Szekvenciásan, egymást követõen kell megírni az utasításokat.
		
A Unit teszt és a kód együtt evolválódik. Lehet akár metódusonként is.

Integrációs teszt: Több osztály kollaborációjának a munkáját fedjük le.
	Dependency Injection = Meg kell adni a függõségeket. P.:logger, filerendszer, adatbázis, winchester, távoli service. 

Dependenciák feloldása:
	Stub: olyan objektum ami vissza ad egy olyan értéket amit mi mondtunk neki h adjon vissza.
		Vagy konstruktor v setter seígtségével át tudjuk adni. Egy valódi objektumnak a helyettesítõje.
		A metódusok és változók default implementációt kapnak. Az objektumok null-t, a v áltozók pedig a saját egyedi alap értékeiket.

Mocking framework:
	segítségével autómatikusan stub-okat vagy mock-okat hozok létre. Mágikus csere objektumok.
	Attribútumok default implementációval térnek vissza.
	EasyMock is egy ilyen mocking framework. PowerMock már tud a final-ökkel is vmit kezdeni.
	
	Emlékszik az objektum hogy az interakció megtörtént-e? Kollekciók:  
	rec():
	
	release():
	
	verify():
		
		
Sorrendiség vizsgálat:	
		control.checkOrder(true);
		<a kettõ között garantált az utasítási sorrend>
		control.checkOrder(false);
		
Control az egy olyan zsák amibe mockokat lehet dobálni
			control = EasyMock.createControl();
			utasitas1 = control.createMock(Service.class);
			utasíitas2 = control.createMock(Service.class);

Stub: Függõségeket cserél le, buta csak visszatér értékekkel.
	A unit teszt hozza létre, vagy mi hozzuk létre kézzel.
		Problémák: behaviour teszt írása void visszatérés esetén nem vizsgálja az interakciókat.
	
SUT: System Under Test a tesztelés alatt álló objektum (általában egy Class): Nem a valódi függõséggel komunikál a kliens

A Mock ugyanaz mint egy Stab, csak õ megjegyzi h mi történt vele, egy kollekcióba belepakolgatja az interakciókat.
	Mockot lehet csinálni classból, interfészbõl, absztrakt osztákyból. Ilyenkor azokból egy "kvázi" új objektum jün létre,
	Maga az adott osztályba nem megy bele a kódlefedettség mock létrehozása során, ha csak tényleg nem hozunk létre abból egy új példányt.
	A statikus metódusok azonban

Mocking framework arra szolgál h stub-okat és mock-okat csináljunk vele könnyedén.
	A jar-t ár kel pakolni a classpath-ra.
	Létrehozzuk az mock objektumot
	Felvesszük az elvárt viselkedést a recording státuszban interakciókat hajtunk végre a mock-kal
	Visszakapcsoljuk replay statusba. Minden ami innentõl történik vele az a valóság és azt kell összehasonlítani a felvett státusszal.
	Meghívjuk a tesztelendõ metódust, majd az interakcióba lép a mock-kal.
	Meg kell vizsgálni a verify-jal az állapotokat.
	//a verify azt biztosítja h a mock tesztelendõ metódusának hívása megtörtént-e.
	
	service = EasyMock.createStrictMock(service.class) <= a Strict-séget növeltük mindenhol autómatikusan életbe lép a check order.
	service = EasyMock.createNiceMock(service.class) <= a Nice-ságot növeltük mindenhol autómatikusan életbe lépne az ahányszor akarod(return anytimes), gyakorlatilag stub-bá tettük.

	
EasyMock
	Alapból rec státusszal jön létre, és az interakciókat egy collection-be menti. A replay() hatására megáll a felvevés és
	mostantól a replay collection-be pakolunk. A verify() összehasonlítja a két kollekciót.
	Ez a feature a különbség a stab és a mock között.
	Konkrét értékekre elég a stab, void-ra már mockot kell alkalmazni.
	
	Történjen meg a metódus hívás és adja vissza az elvárt értéket:
	EasyMock.expect(mock.getName()).andReturn(KONSTANS);
	
	
Argument matcher:	
		EasyMock.anyObject(String.class)
		EasyMock.expect(service.getTimestamp(EasyMock.eq("asdf"), EasyMock.anyObject(String.class)))
		Az EasyMock.eq azért kell, mert különben elszállna, az összes paraméternek Argument matchernek kéne amúgy lennie. Így nem muszáj.
		

Dinamikus mock: Futás közben jön létre és szûnik meg, nincs a filerednszerben manifesztációja.

Covarege tool: Megmondja hogy mi az a kódsor ami lefutott a unit teszt futása közben és mi az ami nem.
	Nem a teszt esetek lefedettsége a fontos, hanem a kódé.
	
	Amiben logika van azt le kell tesztelni. Nem tekintjük logikának a hagyományos gettereket, settereket, mert õk indirect módon tesztelõdnek le.
		P.:Adathordozó java bean-ek.
		
	Absztrakt osztály tesztelése során nem jó megoldás annak példányosítása, legfeljebb parciális mock(csak bizonyos metódusok legyenek mockolva) segíthet.
		A helyes viszont a belsõ osztály létrehozása a teszt metódusban.
		
	Statikus metódusokat nem tudunk mockolni. (komplex logikát ne írjunk statikus metódusba, mert elvesztõdik az objektum oriáltság egyik princípiumát)
		PowerMock-kal staiktus metódusokat is lehet mock-olni.
		
	EasyMock nem tud sem final metódusokat, sem final osztályokat mockolni.
		A probléma az h a tesztelés során ilyenkor hibásan zöldre vált a teszt.
		Ha egy osztály final akkor az összes metódusa is final.
			Ilyenkor hátha lel lehet venni az finalt //Egyeztetni kell
	
	
	Sárga: parciálisan fedted le az adott sort: false-ra meg lett nézve, tru-ra meg nem. Legkisebb base unit of testing.
	
	Anytime esetén nem lehetünk biztosak h tényleg lefutottak a metódusok, annak ellenére h zöldet kaptunk.
	
	Tud aggregálni h összességében hány %-on állunk. 
	
	Képes a historizmusra, idõbeliséget tud kezelni naplózással.
	
	A code coverage azt mutatja meg hogy a unit teszt futása során a kód hány%-át, mely sorait érintette, 
	nem pedig azt hogy mely sorokra írtunk tesztet!!!
	
	XX-ikon Remove all Sessions: visszaszínezi a kódot (Coverage view-ban található).
	
	Ha egy metódust egy másikból hívunk akkor a másik tesztelésénél dizájn döntés hogy az eredeti ellenõrzése mellett a hivóban is végezzünk-e ellenõrzést.
	
	Ha egy konstruktor privát de le akarjuk tesztelni az osztály metódusait akkor tegyük a konstruktort public-ká és 
		tegyünk a konstruktor elsõ sorába egy kivétel dobást.

	NotNull esetén nem vizsgáljuk meg h mit nem kéne csinálni, tehát az az ág felesleges s így a teszt metódus is (?).
		null paraméter tesztelése:
			//GIVEN
			Object input = null;
			//WHEN
			try{
				Adottosztaly.adottMetodsuNemNull(input){
					//THEN
					Assert.fail("ide minidg írjunk valami üzenetet!");
				}catch(IllegalArgumentException e){
					Assert.equals("Null parameter is illegal", e.getMessage());
				}
			}

		
Egyszerû, átlátható, magáért beszélõ dependencia hálót kell készíteni.
Alacsony ciklomatikus komplexitásra való törekvés.		
Test Unfriendly Features: ami lassan fut le, filerendszer, hálózat, hosszú számítások, statikus változók. Ezeket szeretnénk kimockolni.
Test Unfriendly Construct: Nyelvi elemek vagy azokból alkotott struktúrák melyek bonyolult rendszert alkotnak(?) 

Test unfirendly konstrukció (static, final): amit mockolni szeretnénk ne legyen ott ahol nem lehet mockolni. 
	Ne csatlakozzunk final metódusokból hálózatra, filerendszerre.

Felelõsségi köröket ne merge-eljünk össze.	

Minél közelebb legyen a kód elkészítése és tesztelése egymáshoz. Lehet minuszban TDD.

TDD:
	Elõször létrehozom az osztályt, majd azt ami tesztelni fogja õt.
		Elõször a hibás állapotot kell elõidézni, majd megcsinálom azt amit akartam.
		Egészen addig csinélom amígg van követelmény a metódushoz, amit még nem teljesesítettem.
		Lehet h a végeredmény csúnya lesz, s ilyenkor refaktorlni kell.
		

Mockito:
	Egy dr jar-ra van szükség, amit rá kell tenni a classpath-ra.
	Vagy:
		https://examples.javacodegeeks.com/core-java/mockito/mockito-maven-dependency-example/
	Egy alkalmazáson egy mocking framework legyen.
		
	EasyMock vs Mockito

		Mock létrehozása:
		
			EasyMock: EasyMock.createMock(AdottOsztaly.class);
			Mockito: @Mock annotáció, majd alá private AdottOsztály változó.
				@Before
				public void setup(){
					MockitoAnnotations.initMocks(this);
					
					underTest = new Client(service);
				}
				
			Meghívás és ellenõrzés:
				//GIVEN
				BDDMockito.given(mock.getName()).willReturn(KONSTANS);
				//WHEN
				String result = underTest.getServiceName();
				//THEN
				BDDMockito.verify(service).getName();  //ellenõrzés hogy megtörtént-e a hívás(?)
				Assert.assertEquals(KONSTANS, result)
			
			Nem kapcsolgatunk státuszokat Mockitoban. Magában megvizsgálja, felveszi h mi történt és majd vagy megvizsgálom, v nem.
			Ketté bontom amikor stub-olok és utána vagy megteszem az elvárásomat a verfy-jal vagy nem. Alapvetõen minden nice mock.
			EasyMock-ban akkor kell többet írnom h valamit nem akarok. Szigorúbb, kötöttebb, behaviour-istább.
			
			Mockito-ban akkor kell többet írnom ha mockista akarok lenni és viselkedést is akarok tesztelni.
			Mindig letsztelem mockista esetén a visszatéréseket, azok számát, és sorrendjét, 
			nem csak akkor amikor az összehasonlításhoz szükséges az abból kapott érték.
			
			Sorrendiség esetén egy controllra van szükség a Mockito-ban.
			InOrder inorder = BDDMockito.inorder(serviceMock, maskMock, robbMockraIsMegadhatom);
			inorder.verify(service).connect();
			inorder.verify(service).getContent(indent);
			inorder.verify(service).release();
			
		
TestNG: Unit testing framework. Okosabb mint a junit		
		Komplex tesztek megoldására szolgál, egy frameworkön belül meg lehet valósítani a unit és integrity teszteket.
		Extra belépési pontok és Before és After annotációk.
		DataProviders:
		Különbözõ tesztcsoportok létrehozása.
		Timeoutok kezelése integrációs tesztek esetén.
		Tesztmetódusok esetén függõségeket lehet megadni, ami unit testek esetén ugyebár teljesen irreveláns, mert ott nincsenek egymásra hatással a tesztek.
http://testng.org/doc/documentation-main.html


A while loop-ot úgy kell tesztelni hogy mindkét ágba bele menjen, hogy a konzolról bekért üzenetek közé megadunk egy rosszat és egy jót:
		// Given
		BDDMockito.given(consoleInteractor.readFromConsole()).willReturn("badAccountformat", "goodAccountFormat");
	
		// When
		Player player = underTest.createPlayer();
		// Then
		Assert.assertEquals("badAccountformat", "1-1", player.getAccountNumber());
	