Tervezési minták

3 Fõ típusa:

-Creational (Létrehozási)
-Structural
-Behavioural (Viselkedési)

1. Közös nyelv a fejlesztõk között
2. Jó szokások elsajátítása
3. Gyorsítja  fejleszéti folyamatot (nem kell a nulláról indulni, kész ötleteink vannak)
4. Szeretnénk elkerülni a csapdákat, 
5. Egybõl a jó megoldás irányába mehessünk, ne kelljen az alapoktól indulni.
6. Gyakoroljuk az oo-design-t

Kompozíció: Szoba és a 4 fala. A szoba felel azért hogy meglegyenek a falak.

Aggregáció: Az autó és a 4 kerék: A kerekeket át tehetem egy másik autóra.

Asszociáció: Van egy attribútum, de nem képviseli a rész egész viszonyt.

Dependencia: Meghívunk rata egy metódust, de nem tároljuk el a referenciát. Lehet hogy módosítani kell a nyíl másik végén áll ó osztályt ha a másik oldal változik.

Delegáció: Nem akarom megoldani, áthárítom másra a felelõsséget.

Absztrakció: Elhagyunk bizonyos részleteket amelyek irrelevánsak az adott szinten.

Absztrakt osztályban több részlet kell hogy megjelenjen mint egy interfészben (attribútumok)

Az asszociáció és a dependencia között az a különbség hogy az asszociációt úgy kell elképzelni mint ha névjegykártyát cserélnénk,
míg a dependencia csak egy sima találkozás az utcán, utána már nem lehet kapcsolatot létesíteni.

------------------------
Öröklõdés							vs							Kompozíció

Fehér dodoz														Fekete doboz
Ha öröklök egy másik osztályból 								Csak a publikus metódusokat látjuk
akkor láthatok plusz dolgokat (protected)
Ha többet tudok akkor több változásra leszek érzékeny

Könyebben használható, a kódban rögtön tudjuk					Nem mindig tudjuk h mi vana másik oldalon,	
hogy melyik osztályból örököl.									nem tudjuk ki fogja megvalósítani. 
																Futás idõben dölhetnek el dolgok.
																
Osztályok közötti kapcsolat.									Objektumok közötti kapcsolat.	

Ha biztosra mehetünk hogy az õs osztály nem fog változni.
Pl.: Library osztályok.
------------------------

A statikus inicializáló blokk akkor fut le amikor betölti az osztályt a virtuális gép.
A sima inicializáló blokk pedig akkor amikor az osztályból példányosítunk.
Minden esetben a konstruktor elõtt futnak le, deklarálási sorrendben.

Privát konstruktorú õsosztályból nem tudunk leszármaztatni, mert a gyerek osztály nem tudja meghívni, 
ilyenkor a final-t is illik kitenni az õsosztály neve elé.

Miért jó egy immutable objektum:
Bárhol fel tudjuk használni.
Szálbiztos. (Mivel nem tudják módosítani, nem is tudják elrontani) // (Konstruktorból nem jó ötlet szálat indítani)

volatile = illékony: minidg fordulj a központi memóriához és onna kérdezd le a legaktuálisabb értéket, mert lehet hogy azt egy másik szál módosítja.

Három probléma lehet többszálasítás esetén:
- Sorrendiség
- Atomicitás
- Láthatóság

final kulcsszó mezõn: legkésõbb a konstruktor lefutásakor értéket kell kapnia. Ha már egyszer értéket kapott utána nem lehet megváltoztatni.
final kulcsszó osztályon: nem lehet belõle leszármaztatni.
final kulcsszó metóduson: nem lehet leszármaztatott osztályban felüldefiniálni.
final kulcsszó metódusparaméteren: függvényparamétert nem lehet megváltoztatni, nem mutathat másra.


static kulcsszó attribútumon vagy metóduson
static kulcsszó belsõ osztályon
static inicializáló blokk
static kulcsszó statikus import

----------------------------------------

Creation Patterns:

-Abstract factory
-Buidler
-Facory method
-Prototype
-Singleton

----------------------------------------

Creational Pattern:

-El akarjuk fedni hogy melyik osztály és hogy milyen objektumot hozott létre. Class Creation
-El akarjuk fedni hogy milyen a felépítése az objektumnak. Object Creation

Bonyolult létrehozáis minták megkönnyítésére hivatott.

A new és az instanceof-ot általános tendencia szerint kerülni kell.

Szeretnénk elérni azt hogy a mi rendszerünk legyen független attól hogy:
- hogyan hozunk letre objektumokat, 
- hogyan állnak össze és 
- hogyan vannak reprezentálva
azért hogy aki használja a mi osztályunkat ne kelljen ezzel foglalkoznia.

Immutable tulajdonsághoz nincs köze a konstuktor paraméterek finalizálásának.

----------------------------------------

Builder:

El szeretnénk szeparálni az objektum felépítését attól hogy hogyan van õ reprezentálva.

Pl.: Közös builder interface ami egyik json-ból, másik xml-bõl olvassa fel az adatokat.

Egy interface alá többféle builder osztályt is betehetünk. Testvérek irányába terjeszkedhet tovább ez a minta.

getResult() metódus ami visszadja h mit hoztunk létre. //vagy olyan jellegû

Szokták láncolni ezeket a metódusokat. (Önmagukkal térnek vissza. Veszélyes lehet ha valahol megtörik ez a lánc)

Összetetteb algoritmust akarunk elszeparálni a létrehozandó objektumtól.

Nagy elõny hogy el lehet nevezni a konstruktor paramétereket.
A paramétereket is tudjuk validálni.

Pl.: StringBuilder - a toString a getResult() metódusa. PlanetBuilder példa. A PlanetBuilderen sorba lehet hívni a settereket().

----------------------------------------

Factory method:

Az objektum létrehozásra interfészt adunk, metódust kell deklaráljunk, így a leszármazott osztályok el tudják dönteni hogy mit példányosítsanak.
Használhatjuk a polimorfizmust létrehozási metódusok esetén. 
Nem veszítjük el azt a rugalmasságot h a leszármazott osztályok ne tudják eldönteni hogy milyen példányokkal dolgozzanak.

Utaljunk rá: NewInstance, Create...

Leszármazottakra akarjuk bízni h milyen típust példányosítson.
Lehet statikus is. Az a dolga csak hogy gyártson példányokat. Nem muszáj mindig újat létrehozni, immutable-t is visszaadhat

Privát v protected legyen a konstruktor.

Pl.: Object.toString();

Jellemzõi lehetnek:
- Visszatérhet egy új példánnyal, de nem muszáj.
- Absztrakt osztállyal v interfésszel tér vissza.
- Leszármazottak felül fogják definiálni

Pl.: Iterable interfész (Halmaznál teljesen mást kell csinálni mint egy indexelhetõ kollekciónál).
ThreadFactory: Többféleképpen tudják felparaméterezni a konkrét szálakat.
Visszatérhet önmaga leszármazottjával(WTF?)




----------------------------------------

Singleton:

Azt szeretnénk elérni hogy egy osztályból egyetlen példány keletkezzen és hogy ahhoz globális hozzáférés legyen.
Pl.: Alkalmazás fõablaka. Statisztika gyûjtés egy központi objektumon belül.
Nehéz átalakítani, kijutni belõle ha meggondoltuk magunkat h mégis több példányra volna szükség.

Implementálása:
privát statius mezõ: instance
public static method: getInstance()
privát konstruktor

Mûködése kétféle lehet:
Rögtön betöltõdik: Eager loading
Csak az elsõ használat során gyárjtuk le: Lazy loading (Élatalában ezt használjuk)

Konkurensen használják ezt az egy objektumot.

Synchonized double check idioma: kétszer ellenõrzünk rá: egyszer szálbiztos, egyszer nem szálbiztos környezetben.
A cél a telejesítmény növekedés.
Nem teljesen jó megoldás, mert már a konstruktor futása során az építésre lefoglal memóriát. Erre jó a volatile hogy egy lépésben csinálja meg a konstruktort.
Általában ne csináljuk double check locking singletont. A kerertrendszerek megoldják helyettünk.

A Lazy loading singleton beágyazott belsõ statikus osztályban való implementálása nagyon jó, mert a JVM biztosítja h csak egyszer futhasson le. 

----------------------------------------

Prototype:

Õsosztolyába belerakom h a konkrét objektum létrehozásánál külön-külön kellenek.
Általában csak akkor használjuk ha valamilyen üzleti logika miatt van jelentõsége.
A klónozásnál arra kell figyelni hogy deep copyt használjunk(az atrribútumokat is klónozzuk).
A deep copy esetén a körkörös hivatkozásokat is le kell tudni kezelni.
Ezzel ellentétes a shallow-copy, ami csak referencia szerint másol. Egyszerû memórai alapú másolás is ezt használja.

----------------------------------------

Struktúrális minták:

Kisebb objektumok lássanak el bonyolutabb feladatokat.
Objektum orientáltáságot kihasználva tudjunk megküzdeni a komplexitással.
Ugyanarra a nyelvi eszközökre épít mint a delegáció/kompozíció csak más más perspektívából.

Adapter: 

Kényszerhelyzetet próbál megoldani. Adott egy interfész és adott egy implementáció.
Szeretnénk elkerülni az új implementációt ezért megpóbáljuk behúzni az interfész alá az implementációt valahogy.
Meglévõ, bonyolult implementáció újrafelhasználása hatékonyabb mint egy újat írni nulláról.
pl: Arrays.asList(); Listeners és belseõ osztályok. HashSet

	Résztevõk:
		Target: az interfész amit implementálni kell. Csak ezzel a target-tel kommonikál a kliens.
		Adapter: csak delelgálja a hívásokat request(). Legfeljebb csak alap konverziós mûveleteket végez el.
		Adaptee: Ide hív be az Adapter.


Bridge:

Célja: Absztrakciót elszeparáljuk az implementációtól. Kompozícióval oldjuk meg. 
Futás idõben eldönthetjük hogy mely implementáció kerüljön be.
Az absztrakciónak lehet több leszármazottja és lehet többféle implementációnk is.
A lényeg h különválasszuk az absztrakciót és az implementációt és a kettõt kompozíciós kapcsolattal kössük össze és ne örökléssel. (pl.:Annotációval való összekötés vagy konfigurációs fileban)

A kliens nem fér hozzá az implementációkhoz. A kliens egy absztrakcióval van kapcsolatban, ami kompozíacióval van összekötve
egy impplementorral, amit ConcreteImplementorok valósítank meg.
Mind az abstraction-nak, mind az implementornak kiterjeszhetõnek kell lennie.

Mûködése: Absztrakció csak továbbítja a kliens kéréseit, legfeljebb kényelmi metódusokat tartalmazhat.
Implementáció: Gyakori eset hogy csak egy implementáció van. Futási idõben dõl el, vagy külön konfigurációs fileban van, vagy annotációval dõl el.

Mikor használjuk?
Ha az implementáció változhat futási idõben. Ha az absztrakció és az implementáció egymástól külön-külön is változik.
Pl.: sql.DriverManager 

----------------------------------------

Decorator:

Nagyon gyakran szükség van arra h dinamikusan bõvítsünk ki egy osztályt h plusz felelõsségeket lásson el (vagy vegyünk el ).
Mivel az öröklés az statikus így nem tudjuk megoldani. Itt is kompozícióval oldjuk meg.
Példa.: Scrollozható panel. Ha nincs rá szükség akkor nem jelenik meg a sáv. Más pl.: Streamek egymásba ágyazása.

Egy Componenet alatt van a kkonkrét komponens és a Decorator egymással egy szinten és a Decorator operation() (vagy hasonló nevû) metódusa kerül
implementálásra ConcreteDecorator-okban.

2-3 dekorátor esetén már megéri alkalmazni.

Interface conformance: A decorator és a konkrét komponens közös interfészre kell hallgasson.
Felelõsségeket dinamikusan akarunk hozzáadni/vagy elvenni.



Facade:

Cél: Egyszerûsített, egységesített hozzáférést biztosítson valamilyen bonyolultabb alrendszerhez.
Lazítani a kliens és az alrendszer közötti coupling-ot.
Legtöbb API rendelkezik ilyennel. Pl.: Java persistance API
Rétegzett architektúrában a retegek közötti kommounikációt gyakran megkönnyíti.

Feladata: Delegálja a kéréseket.

Nem fedi fel a belsõ osztályokat. A Faceade nem implementál semmit, legfeljebb valalmi kis konverzió.
A cél az hogy alrendszer osztályok ne tudják hogy egy facade alatt dolgoznak.

pl.: Simple Logging Facade for Java (SLF4J)

 
Proxy:

Helyettest biztosítunk egy objektumnak és azon keresztül fogják õt használni.
Védelmi proxy: van-e jogosultásga a kliensnek az adott hívást elvégezni.
Megtudja számolni hogy hány referencia van erre az objektumra (smart pointer).
Általában távoli eljárásíhvások esetén használatos.

A helyettesítendõ és a proxynak közösnek kell lennie az õs osztányak vagy az interfésznek hogy a kliens ne lásson különbséget.

Mûködése: Csak továbbít küldéseekt vagy beavatkozik h ne küldje le.

Dinamikus proxy: Kódban nem, vagy nagyon kevés megjelenése van.
Virtuális proxy: Lazy Loading jelleggel való inicializálás. Pl.: Csak akkor példányosítom az objektumot ha valóban szükség van rá.
Protection proxy:


Composite:
Rész-egész viszony (bekezdés-sorok-szavak)


Flyweight:
Több kliens is ugyanazt az objektumot használhatja, nem kell mindig újat objektumokat. Intgere.valueOf() = -128 tól +127 ig kesseli az objektumokat.

----------------------------------------
 
Behaviour patterns:

Hívások megtörténtét vizsgáljuk egy bonyolutabb struktúrában. A kommunikációrol van szó.
A legfontosabb feladat annak a vizsgálata hogy osztályok között hogyan osszuk szét az összetett felelõséget amit fel szeretnénk bontani.
Minél gyengébb kapcsolatot kell alkalmazni hogy a modell flexibilis legyen.

Command:

Egy kérés nem csak egy metódus hívás pillanatnyi helyzetét jelképezheti, 
hanem egy kérést egy objektumban is elhelyezhetjük.
Ma beadok egy kérést, holnap kell pl. lefuttatni. Priorizálni lehet várakozási sorban.
Visszalépeseket is meg lehet vele könnyen valósítani (sakk program).
Naplózásnál is fel lehet használni.
Runnable(átadunk egy szálnak h késõbb lefuttassa)
Callable(ugyanez csah ahívásnak van eredménye, emit szeretnénk visszakapni)

Iterator:

Úgy biztosítsunk hozzáférést egy kollekció elemihez hogy közben ne fedjük fel belsõ szerkezetét.
Aggregate: maga a kollekció

External iterator: ? Ez a gyakoribb
Internal: átadunk neki egy eseménykezelõt. 

Általában nem támogatják a konkurens hozzáférsét. A remove mûveletet még lehet használni, de másik helyrõl nem szabad módosítani.
Gyakran belsõ osztályként valósítják meg.


Mediator:

Viselkedést ábrázol. Összetett programokban sok-sok objektum kommunikál egymással hálóban.
A mediátor központi elemként lebonyolítja ezeket a kapcsolatokat a kommunikáló felek között.
Az egymással kommunikáló felek a "kollégák" akik között nincs nyíl, mert nem ismerik egymást.
Csak a mediátor ismeri a feleket.
A meidátor feladata hogy definiálja a kommunikációs formát az egyes objektumok között.

Pl.: GUI, JMS, SmartHome excercise


Observer:

A kommunikló objektumok közt lévõ több-több kapcsolatot hoz létre.
A Mediator speciálisabb változata.
Subject: Figyeli azokat akik feliratkoztak az õ eseményeire. 
Observer: tudniuk kell hogyan kezelje le ezeket az eseményeket.
Observer-interfész; Observable: absztrakt õsosztály
Egyik object úgy tud üzenni a másiknak anélkül hogy konkrétan ismerné azt.
A mediátor alternatívája.


Strategy:

Különbözõ algoritmusokat tudunk definiálni és szabadon akarunk váltogatni közöttük közös interfész segítségével.
Pl.: LayoutManager.
Közös interfésszel rendelkeznek. Egy konteszktussal szorosan együtt mûködik h implementálni tudják ezt a metódust.
Ha adott két osztály és csak egy kicsiben tér el az implementációjuk akkor Strategy-vel ezt el lehet kerülni.
Comparator: Mi szerint rendezzünk és hogy (növekvõ v csökkenõ rendezés)

																											
Template method:

A Strategy tervezési minta alternatívája. 
Rendezésre, játékstratégiára használjuk, csak itt öröklést használunk kompozíció helyett.
Cél: Egy vázat adjunk egy algoritmusnak és hagyjuk a leszármazottakra hogy ezt a vázat hogyan töltik fel.


