Node egy futtatási környezet, ami végre tudja hajtani a JavaScript kódot.
A Node az nem egy programozási nyelv.
A Node nem egy framework.
Inkább egy engine.
//REST framework-ök HapiJs, Loopback
//Babel modul ES6-os forráskódot ES5-ös forráskóddá alakít.

Régen JS appokat csak browserek futtattak (Õk biztosítottak Runtime Environmenteket).
A leggyorsabb JS engine a Chrome V8 (2018), ami egy C++ plogram, amit csak Node (Node.exe) hívunk.
A node a JS enginen kívúl még plusz modulookat is tartalmaz.

JS kód -> JS Engine -> Machine kód

Fõ karakterisztikái:
	Asynchronous (A Single Thread is used to handle multiple Request. Pincér(Thread)-Request(Vendégek -Concurrent Clients)-Chef(feldolgozó(DB))) alapból-
	EventDriven
	NonBlocking I/O -> Ideális I/O (Adat) intenzív, valós idejû alkalmazások számára.
		Sok ügyfelet tudunk kihasználni úgy feleslegesen erõforrásokat csatolnánk fel.
	Ne használjuk CPU intenzív alkalmazások esetén.	(Videó kódolás, kép szerkesztés)
		

Az event Loop a NodeJs lelke (Powered by Libuv - libuv is a multi-platform support library with a focus on asynchronous I/O. It was primarily developed for use by Node.js, written in C++. Cross-Platform(EventLoo, Async I/O))
Egy SingleTreaded alkalmazás nagyon sok kapcsolatot képes egyszerûen kezelni.
Könnyen skálázható,
Valós idejû alkalmazások,
Agilis fejlesztés,
JavaScript
Hatalmas open-source libek ecosysteme

Kik használják:
PayPal, Uber, Netflix,..


Verzió:
	node -v
	
Futtatás:
	node fileneve.js
	
npm init:
		létrehozza a stuktúrát
History:
	2009 ben készült
	2011 ben lett hozzá NPM- Node Package Manager.
	2015 node.js 4-released
	
	
Alapkoncepció:
	Adott egy étterem amiben maga a pincér a NodeJs. Egyedül van (Single Treaded) és õ veszi fel a rendeléseket(requests)
	egy esemény queue-ba a vendégektõl(users) és visze el a séfhez(file system). 
	Azért aszinkron mert nem kell várni hogy egy rendelés elkészüljön, hogy kivihesse a konyháról, hanem
	közben felvehet újakat.
	
Mikor használunk async funkciókat?
		Filre rendszer
		Esmények
		Streamek
		DB mûveletek
		
Global Objects -mindenhonnan el lehet érni õket.
	ilyen pl a console.
	Mivel midenhonnan elérhetõek nem kell kitenni elébük a global kulcsszót, mint hogy global.console. Szimplán csak: console.log("Hello world").
	
Ha változó tartalmát akarjuk kiiratni:
	var justNode = "Node";
	console.log(`Hello ${justNode}`);
	
Trükkök:
	console.log(__dirname);
	console.log(__filename);
	
path modul használata:
	var path = require("path");
	
Mivel nem a böngészõben fut, más objektumokat tud elérni:
	document.getElementById('') <- ilyen nincs.
	fs.ReadFile() -> FileSystem
	http.createServer()
	
EventQueue: Az esemémysorra teszi a kéréseket, amit folyamatosan monitoroz a háttérben, ha elkészült, akkor vissza szolgáltatja az eredményt a kérõnek.


Emitterek:
	Számos függvénye van:
		on(type, listener) Ez kapja el (erre vagyunk feliratkozva), ha rámeccsel a típusra és hajtja végre az adott funkciót.
		emit('', function) Ez bocsát ki.
		
	Memory leak(ha túl sok listenert teszünk egy eseményre)
	


Modul: JS kódok gyüjteménye/ összessége amelyek egy-egy jól körülhatárolt feladat végrehajtására hivatottak.
	Consider modules to be the same as JavaScript libraries.
	A set of functions you want to include in your application.
	Miért van rá szükség?
		Scope izolálás (API-jaink ne keveredjenek a globális scope-on (újradeklarációs hiba) <-Megoldás NameSpacek)
		Dependency management
		Protabilitás

		Megvalósítások:
			AMD (Asynchronous Module Definition pattern) - Régi	//Böngészok használják foleg.
			CommonJS (Minden modulnak saját scope-ja van)		//NodeJS használja, de nem csak o.
			EcmaScript 6										//Az import a required megfeleloje	//exportot oda tudjuk írni bámi(?) elé. 	
			UMD													//Universal Module Definition, mind ES, mind CommonJS környezetbe beimportálható
			
		//Browserify alkalmazás: az összes az alkalmazás által használt modult-t beteszi egy nagy JS-file ba h tudjuk használni a böngészoben is.
	
	exports = olyan mint a windows objektum, minden file esetén egyedi.

//Az exports az egy property a modulon(?) - kicsit olyan mint az alert a window-on.

A module.export-ot el tudjuk érni a modul prefix nélkül is.

Egy package-nek van egy entry pontja: Amit a package json-ben megadunk. Ezt a filet fogja arequire js betölteni, ha azt a mappát beinclude-olom.

Van különbség a között h mi futtatjuk a modulunkat cli-bõl, és a között ha a mi modulunkkat hívják.

//module.parent segíthet eldönteni h út behúzták va futtatott.

Ha van ugyanolyan nevû file kiterjesztés nélkül, akkor a file-t tölti be nem megy tovább az ugyanolyan nevü mappába.
Ha behivatkozok egy modult, és nincs kiterjesztés, akor másodjára belemegye egy olyan nevû mappába és az azon belül lévõ index.js-t futtatja.

Ha nincs include nál megadva "./" -akkor a file helyéhez képest legközelebb elhelyezkedõ (felfelé-rekurzívan) node_modules mappát

Beépített modulok:
	http


	