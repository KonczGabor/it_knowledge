https://learngitbranching.js.org/
	-undo or reset to fix mistakes, nem kell újrahívni az oldalt.
	
https://www.bogotobogo.com/DevOps/SCM/Git/Git_GitHub_Fast-Forward_Merge.php
	Sok hasznos tutorial a végén
	
Azert erdemesebb CLI-t használni:
	Mert néhány GUI nem implementálja a teljes funkció készletet,
	Mert más CLI toolokat is ha használunk akkor gyorsítjuk a munkát,
	Mert neten több segítséget kaphatunk az egéyrtelmú parancsok miatt.

GIT:
	Decentralizált/elosztott verzió kezelő rendszer. //Mégis a gyakorlatban egy centrál repót használunk általában.
	Eredetileg Linux Kernel projektek verziózására hozta létre Linus Torvalds.
	Csak egy pár parancshoz szükséges net kapcsolat, nagyon sok minden működik lokálban.	
	
Repository:
		A verzió kezelés alatt álló fileok(és mappák) illetve azok történelmi gyűjteménye.
		A struktúra gyökerében található a .git folder
		
A commit egy pillanatfelvétel/snapshot a jelenlegi változásainkról ami mindenazon fileokat tartalmazhatja amiket a vágólapra (stage) tettünk.
	A git fileokat kezel, nem foldereket. Ha mappa szerkezet változásokat szeretnénk megörökíteni akkor hozzunk létre az új mappákban üres dummy fielokat.
	
A branch csak az idővonal neve, amire fel vannak fűzve a commitok. 
	A branch törlése csak a labelt törli.
		
GitHub:
	Git repository hosting service.
	Unlimited frre repo if public is it.
	+szolgáltatások:
		IssueTracking
		Web Pages		
		
Install:
	Recommended:
		Checkout as-is, commit Unix-style linde endings

Create new SSH public_key:
		$ ssh-keygen -t rsa	
	
Show own config file:
		git config --global -e
	
$ git config --global user.name "John Doe"
$ git config --global user.email "johndoe@example.com"
$ git config --global core.editor "notepad++ -multiInst -nosession"

Checking Your Settings:
	$ git config --list
	git config -l

P4Merge for Windows (perforce.com):
		Visual Compare and Merge tool
		A Command Line Merge idegesítő
		During installation deselect all others but Visual Merge Tool
		git config --global diff.tool p4merge
		git config --global diff.tool p4merge.path "C:/Program Files/Perforce/p4merge.exe"
		git config --global diff.tool.prompt false
		git config --global merge.tool p4merge
		git config --global merge.tool p4merge.path "C:/Program Files/Perforce/p4merge.exe"
		git config --global merge.tool.prompt false
		
ssh-agent sh -c 'ssh-add ~/AsusWin7_private; 

Merge conflict:
	Mikor ugyan annak a filenak ugyanazon sorában történt módosítás a két összeolvasztandó branch commitjaiban, akkor nekünk kell beavatkozni manuálisan.

Working Directory: contains all the files and folders for your application (Nem minden áll verziókezelés alatt, de a git attól még figyeli őket, legfeljebb ignorálja. Ennek az állandó figyelés eredménye h észre tudja venni az újonnan született fileokat is)
Staging Area: used to prepare for the next commit. Ezen keresztül visszük át a Working Directorynakban történt módosulásokat commitok formájában a Repositoryba
Repository(.git folder): contains all the committed or saved changes to the Git repository. Anything here is a part of Git's history
Remote repository: Ez valójában csak egy sima repó a maga 3 belső állapotával, általában ez a centrál repó 

help:
	$ git help config


Initializing a Repository in an Existing Directory:
	$ git init [folder]
	Vagy ha már a folder kész van akkor álljunk bele és:
		$ git init .

Cloning an Existing Repository:
	$ git clone https://github.com/libgit2/libgit2

Checking the Status of Your Files:
	$ git status

$ git status -s:
	New files that aren’t tracked have a ?? next to them, new files that have been added to the staging area have an A, modified files have an M and so on. There are two columns to the output - the left hand column indicates that the file is staged and the right hand column indicates that it’s modified.

Add a specific file to the Git staging area of your repository.
	git add .
	git add [file]
	git add file1 file2
	git add *.html

	git add -u : a merge conflict során újra hozzá kell adni az érintett fileokat, így az összeset egy mozdulattal meg lehet tenni.
	Add all new/modified files inside the current directory to the staging area of your repository.

	
Commit everything has been changed	
	git commit -a

Leszedni vmit a stage-ről. Maga fileokon végzett módosítások maradnak. //Ezzel szemben a git checkout . el dodbja a változásokat
	git reset [file]
	git reset 
		Removes all files from the Git staging area but keeps all changes


remove untracked files	
	git clean -df
	

Megszabadulunk egy file lokális változáisaitól és visszaállunk annak utolsó commitolt változatára:
	git checkout [file]
	git checkout .
		Eldobunk minden file össze változását és visszaállunk az utolsó commitbeli állapotukra.

git revert [commit] 
Provides a way to safely remove a previous commit. Git will
automatically remove the changes, and then create a new
commit. This way you still have a history of the change being
removed.


git help log 

git log = megmutatja a commit historyt (A legaktuálisabb van felül)
	q-val lépünk ki
	git log --oneline
		Egysorosított kiíratás
	git log --oneline --graph --decorate --all
		Színesít, minden branchre
	
	git log --author="Kevin"


	git log --grep="init"
	
git show
	Csak az utolsó commitot mutat és a diff-t ami tartalmazza a változásokat.
	q-val lépünk ki
	
git ls-files	
		Megmutatja h mely fileok állnak verziókezelés alatt

//New branch creates from the particular branch where from it has been created. 

git branch [branch_name] 
	Create a new branch (copy of the code) to use to
	develop a new feature or fix a bug.


git branch
	Lists all of the available branches
	The * character indicates the branch we currently have checked out.
	 branch -a: show all branches


git checkout [branch_name] 
	Checks out an existing Git branch. This simply
	switches your code to a different Git branch.


git checkout -b [branch_name] 
	Creates a new Git branch and checks it out. This is
	a shortcut so you do not have to create the branch
	and check it out using two steps.



git merge [branch_name] 
Merge [branch_name] into your currently checked out Git branch.
The first step is to checkout your master branch using git checkout master, after that you can merge in your my_new_feature branch into your master branch by running git merge my_new_feature.
Ahol állok abba merge-öli be azt amit megadok neki.

git merge feature master
A feature-t bemásolja a master-be.

git branch --merged

git branch --no-merge

git branch -d branchName
	Delete branch
	Maga a commitok NEM törlődnek, csak a timeline labelje.
	
git branch -D branchName
	Forced Delete branch

git mergetool 
Opens up an external Diff viewer or merge tool for
merging conflicts.

git  add [remote-name] [remote-url]
	Adds a remote repository called [remote-name] located at [remote-url]. We can now push and pull from this repository (assuming we have permission).


git push -u origin master 
Push our master Git branch to the remote called origin.
$ git commit --allow-empty -m "Trigger notification"

git remote
Lists the available remotes for your current Git
project.

git remote set-url origin git@github.com:<Username>/<Project>.git


git remote -v 
	Provides more information about your Git remotes,
	such as the location and what operations can be
	performed.

git remote set-url origin https://github.com/USERNAME/OTHERREPOSITORY.git


git remote rm [remote-name]
Remove a Git remote from your current Git project.


git clone [git-url] [folder-name] 
Clone a Git repository at [git-url] and place it in a
new directory called [folder-name]


Git branch commands’ various options. -a shows all local and remote branches, while -r shows only remote branches.


git remote and git ls-remote

$ git remote show origin

'git branch -r' only shows unupdate version of remote, git ls-remote will query the remote, thus will list the current version.
If you git fetch, then 'git branch -r' will get the updated list at remote.

git diff
	Két commitot hasonlít össze, nem kell h szomszédosak legyenek
		git diff randomCommitNumber HEAD
	

	git diff --staged
	The last changes on the stage

git difftool
	Ugyanezen^ logika mentén csak meghívja a bekonfigurélt difftolt (pl.: p4merge) 


Branch
	Mirroring a repository to another
	
Clone
	Make a copy from a repository

Push
	push a files to a remote repository

Merge
	Merge to branch to one
	git merge feature_branch_name	//ahol állunk (jelen esetneben a master) oda mergeli be azt amit megadunk. Így "húzunk be" ebben az esetben

Pull
	Is a fetch and a merge
	 --rebase

Fetch
	is a Pull without a Merge
	Handy if you want to compare your code with others

Checkout
	Navigate between created branches
	checkout -b newBranch and cheheck it out

.gitignore	
	Ő maga is verziókezelt, ha nem jön létre alapból. tegyük be a working directory gyökerébe:
	touch .gitignore
	Minden ami generált nem kell h verziókezelés alatt álljon.

Ha nem akarjuk leszedni a projekt mappját akkor álljunk bele ahová le sszeretnénk klónozni és a végére tegyünk egy szóközt és egy pontot:
	git clone git@gitbud.epam.com:Gabor_Koncz/mep-linux.git .

git commit -am"ha nem akarunk előtte külön git add .-tal hozzáadni mindent, s írhatjuk is a commit messaget";

gir commit -a --amend	:	az előző kommitot tudjuk módosítani h ne legyen messy a line. Megnyílik a message editor arra az esetre ha az üzenetet szeretnénk módosítani.

A brench nen más, mint egy pointer ami egy adott kommitra mutat.

Merging in Git creates a special commit that has two unique parents. A commit with two parents essentially means 
"I want to include all the work from this parent over here and this one over here, and the set of all their parents."


Rebase
	Rebasing essentially takes a set of commits, "copies" them, and plops them down somewhere else.
	While this sounds confusing, the advantage of rebasing is that it can be used to make a nice linear sequence of commits. 
	The commit log / history of the repository will be a lot cleaner if only rebasing is allowed.
	
	git reabase master
		ahol állunk azt beteszi a master után és megszűnik ahol álltunk. vessző lesz'

		
HEAD: Egy speciális marker(pointer) Az a commit amire aktuálisan ki vagyunk checkoutolva.
	Általában az adott branch utolsó commitjára mutat, de lehet manuálisan is mozgatni.
	Ha branch-et váltunk akkor annak utolsó commitjára fogunk mutatni.

Amikor detach-cseljük a head-et akkor valójában csak annyi történk hogy egy commitra mutatunk, nem pedig egy branch-re.

Commitra annak hash-ével tudunk rámutatni. Nem kell közvetlenül az adott brenchen állni hogy az adott commitra rááljjak, 
egy másik branchről is közvetlenül át lehet ugrani.
Nem kell megadni a teljes hash hosszát, magától tud következtetni.

Relatíve is be lehet járni a hash-fát:
	Fölfelé lépni egyet: ^	//Kettőt: 
	Fölfelé lépni 4-gyel számút: git checkout HEAD~4
	Akutális jelölő: HEAD. Feljebb léni egyet: git checkout HEAD^
	
git branch -f master HEAD~3
	move by force.
	
A brancheket a branch utasítással lehet mozgatni, a HEAD-et a commit-tal.

git reset HEAD~1
	git reset reverts changes by moving a branch reference backwards in time to an older commit. 
	In this sense you can think of it as "rewriting history;" 
	git reset will move a branch backwards as if the commit had never been made in the first place.
	Valóban kinyírja az aktuális kommitot és visszaáll az egyel előrébb lévőre.


git revert HEAD
	While reseting works great for local branches on your own machine, 
	its method of "rewriting history" doesn't work for remote branches that others are using.
	In order to reverse changes and share those reversed changes with others, we need to use git revert.
	Előre megy és csinál egy C2' -t
	Ne adjunk ^-t meg ha csak egyet akarunk mozogni, mert akkor kettőt megy "előre", nem az előtte lévőrőre áll vissza, hanem az azt megelőzőre.


Ha a head ugyanitt áll mint a branch akkor lehet felváltva használni? Nem tudom van amikor megy.

cherry pick
	Ahol állunk oda beteszi amit kiválasztunk és ráállunk a legutolsóra.
	git cherry-pick C2 C4
	ahol álltunk->C2'->C4'(ezen állunk mostmár)

interactive rebase
	Akkor ha nem pontosan tudjuk mely commitokat akarjuk.

	All interactive rebase means is using the rebase command with the -i option.
	If you include this option, git will open up a UI to show you which commits are about to be copied below the target of the rebase. 
	It also shows their commit hashes and messages, which is great for getting a bearing on what's what.
	For "real" git, the UI window means opening up a file in a text editor like vim.

	When the interactive rebase dialog opens, you have the ability to do 3 things:

	You can reorder commits simply by changing their order in the UI (in our window this means dragging and dropping with the mouse).
	You can choose to completely omit some commits. This is designated by pick -- toggling pick off means you want to drop the commit.
	Lastly, you can squash commits, it allows you to combine commits.
	
	git rebase -i HEAD~4
	A 4-gyel előttünk állóig meggyílik egy párbeszéd, amiben újrarendezhetjük, elvethetjük a rang-en belül történit commitokat,
	ameddig tartott az ablak(~4) onnantól új szál jön létre a kívánt sorrendbe rakott/megtartott commit' -kkel, a régiek megmaradnak.
	Rmáutathatunk közvetlenül(direkt) az adott végpontra a commit hash-ével is, nem kell realtívka lennie.
		git rebase -i C1

Amíg valamit be nem kommentelek az az összes branchez tartozik, nem csak azon amin állok.

Aliasok file-ba , command line ba kell ""(:git config --global alias.hist "log --oneline --graph --decorate --all") :
	git config --global alias.st status 
	git config --global alias.co checkout 
	git config --global alias.hist log --oneline --graph --decorate --all
	//Az alias után is tudunk még írni: 
		git hist -- AdottFile
	
		
	global = user lvl, not repo lvl
	
Az aliasokat az adott user alatt lévő .gitconfig file-ba is menthetjük közvetlen:
	[user]
	name = Calindyl
	email = caridniss@gmail.com
	[alias]
		st = status
		co = checkout
		hist = log --oneline --graph --decorate --all
		lol = log --graph --abbrev-commit --decorate --format=format:'%C(bold blue)%h%C(reset) - %C(bold green)(%ar)%C(reset) %C(white)%s%C(reset) %C(dim white)- %an%C(reset)%C(bold yellow)%d%C(reset)' --all
		
	[core]
		autocrlf = true
		
	
Csatlakozás már kész repóbol egy már meglévő távoliba:
	git remote add origin ssh://...
	
Hogy lássuk mi is a remote-unk:
	git remote -v
	git config --get remote.origin.url
	vagy:
	git remote show origin
	
Delete/Remove commits:
	git reset --hard HEAD~1
	vagy
	git reset --hard <sha1-commit-id>  //Ami még jó volt
	
	Utána:
	git push origin HEAD --force
	
	
Stash:
	A stash egy verem amibe be lehet pakolni azokat a változtatásokat amiket nem szeretnénk az aktuélisan branchünkön látni/át akarjuk lapátolni máshova/később vissza akarjuk hozni.
	A stash levesz mindent amit nem commiteltünk és ehy stash@{id} val beteszi egy verembe, amibe gyűjthetjük a többi stash-el együtt.
	
Merge típusok:
	Fast Forward:
		Legegyszerűbb eset: A parent branchen nem történt munka és mi csak ráolvasszuk a feature-ünket.
		Ebben az esetben nem keletkezik merge commit, kivéve ha használtuk a "--no-ff" paramétert is.
			git merge --no-ff amit_be_szeretnenk_mergelni
	
	Automatic:
		Nincs konfliktus a parent branch-csel, a git aoutómatikusan meg tudja oldani. Ilyenkor merge commit jön létre.
		
	Manual:
		Az autómatikus merge nem lehetséges, merge commit keletkezik a feloldás végén.