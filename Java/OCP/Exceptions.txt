UncheckedExceptions:
	ClassCastException : amikor az objektumot inkompatibilis referencia típusra kasztolom.
	ArrayIndexOutOfBoundsException : ha nem létezõ sorszámra hivatkozok.
	IllegalArgumentException : Ha nem megfelelõ típusú paramétert küldök a metódusnak.
	ArithmeticException : Pl.: Ha nullával osztunk.
	
CheckedExceptions:
	IOException
		FileNotFoundException
		
Throwable, Exception, RuntimeException használatához nem kell semmit külön importolni, mert a java.lang.* részei, ami ugye alapból importálódik.

A thorws-t a metódus deklarálás során a praméter fej után kell tenni, a throw-t annak törzsében definiáljuk. 

catch elõtt nem állhat finally.

Az if-fel ellenétben itt minden utasítást blokkokba kell foglalni.

Kicsit trivial:
	A catch nem csak az éppen olyan ..Exceptiönt, hanem ha leszármazottja a catch-nek, akkor a catch elkapja. Pont úgy ahogy maga az Exceptiön is el kap bármit, ami Exceptiön típusú.

Valamelyiknek lennie kell a try után.

A különbözõ catch-ek az egyre specifikusabbaktól az egyre generikusabbak felé haladnak lefele.

Az Error-t nem recommended h elkapjuk.

A CheckedException-t viszont kötelezõ elkapni és/vagy deklarálni. -> Fordítási hiba ha nem. 

A try blokkon belül deklarált változók nem látszanak ki abból, sem a catch, sem a finally számára nem elérhetõek.

Egy try-hoz tartozó catch()-ek közül csak egy futhat le. Azon belül lehet újabb try-catch-finally, azon belül is csak egy kaphat el, és így tovább..

Ha egy metódus belsejében szépen le van kezelve a hiba, de deklaráltuk a fejében h õ throws valamit, akkor a metódus hívásának a helyén kezelni kell azt a hibatípust, kivéve ha RuntimeException, akkor nem muszáj a hívás helyén kezelni, sem másutt.

|Egy metódust, ami throws-sol nem írhatunk felül új, vagy szélesebb Exception-nel, VISZONT teljesen elhagyhatjuk az throws záradékot!|

Ha szánt szándékkal dobunk egy UncheckedException-t azt az ég világon sehol sem muszáj lekezelni. Nem kell körbevenni try-catch blokkal és az õt hívó metódus fejében sem kell deklarálni. 
	Ellentétben egy CheckedException-nel.
	
Akármilyen mélyen egymásba ágyazunk try-catch blokkokat, a CheckedException dobását-t bámelyik külsõ catch, vagy throws le tudja kezelni és le is kell.

Egymásbe ágyazott try-catch blokkok esetén nem adhatunk meg ugyanolyan nevû paramétert, mint ami már kint deklaárlva lett 
	try {
		throw new IOException("Disk not found");
	} catch (Exception e) {
		try {
			throw new FileNotFoundException("File not found");
		} catch (FileNotFoundException e) { // Ez az "e" kitakarná a külsõt, le kell cserélni
			System.out.print("Failed");
		}
	}

Finally:
	Mielõtt az exceptiön kiesne, a finally ág még megcsinálja a dolgát, és csak utána bugyog fel a metódusból.
	Ha nem kaptuk el a hibát, vagy a catch maga dobott hibát, és a finally is dob hibát akkor a finally fog felbugyogni.
	Nem garantált h minden sora lefut a blokknak, lévén õ maga is tartalmazhat pl.: try-catch-finallyt.
	Nem muszáj h elõtte belelépjünk egy catch-be.
	Muszáj h kapcsos zárójellel legyen deklarálva, ellentétben az if-fel ahol egysoros utasítás esetén elhagyhatjuk.
	
Ha egy metódus catch és finally ágából is dobunk hibát, akkor csak a finally-é fog látszódni a metódus hívásának helyén.

Multi catch: allows you to write code without duplication.

A multi catch-ben megadott kivétel típusok nem állhatnak egymással relációban.

A fõ különbség a Closable és AutoClosable között hogy az AutoClosable bármilyen kivételt dobhat, a Closable csak IOExceptiont. 
RuntimeExceptiont bármelyik dobhat, az nem számít. (Szóval pl. a Closable nem dobhat Exceptiont, de IOExceptiont és bármilyen RuntimeException igen.)
Closeable extends AutoCloseable. (Closable van származtatva az AutoClosable-bõl.)

public static void main(String[] args) {
	try {
		Path path = Paths.get("dolphinsBorn.txt");
		String text = new String(Files.readAllBytes(path));
		LocalDate date = LocalDate.parse(text);
		System.out.println(date);

	} catch (DateTimeParseException | IOException e) {
		e.printStackTrace();					//Itt az e effectively finallá minõsül mutlicatch esetében, tehát nem kaphat más értéket.
		throw new RuntimeException(e);         
	}
 }

the variable name must appear only once and at the end. Using different variable names doesn’t make it any better.

try {

	throw new IOException();

} catch (FileNotFoundException | IOException e) { } // DOES NOT COMPILE

--------------

Java 7 tõl, ha egy Exceptiont elkapunk a catch-ben, akkor azt "lefordítja a helyesre":

public void read() throws SQLException {
	try {
		readFromDatabase();
	} catch Exception e) {
		throw e;
	}
}
------------------

FileNotFoundException is a subclass of IOException. Specifying it in the multi-catch is
redundant, and the compiler gives a message such as this:

The exception FileNotFoundException is already caught by the alternative IOException
--------------------

Only checked exceptions that have the potential to be thrown are allowed to be caught. //Nem kezelhetünk le mondjuk SQL exc-et ha esély sincs rá hogy olyan dobódhat, fordítási hiba.
-------------------


The new try-with-resources statement automatically closes all resources opened in the
try clause. This feature is also known as automatic resource management, because Java
automatically takes care of the closing.  //a try-ból try(resources) lesz
A try-with-resources több erõforrás bezárását is autómatikusan helyesen kezeli. Régen ha ez elsõt nem sikerült, akkor a többi szivárgott.

A try-with-resources megengedi h elhagyhassuk mind a catchet, mind a finally-t. De attól még lehet mind a kettõ. A saját finally-nk utoljára fut le.

A try blokkban létrehozott erõforrások nem látszanak ki abból. catch és finally nem látja õket.

In order for a class to be created in the try clause, Java requires it to implement an interface
called AutoCloseable. // Csak az tehetünk be a try()-rész-be ami megvelósítja az AutoClosable interfészt.

Supressed az az excp ami elõször tûnik fel, de elnyomja egy új, ami primary-vá lép elõ.

A catch blokk a primary exc-et hivatott elkapni, hiába tudná elkapni a supressed-et, el kell azt engedni, most nem azzal törõdik.

Az auto close blokkban lévõ erõforrások lezárása a try{} blokk után történik meg, a catch blokkok lefutása elõtt.

Az erõforrások lezárása fordított sorrendben történik, mint ahogy létrehozva lettek. A lezárási irány tehát lentrõl felfelé halad.

Ha dobunk egy excp-et a try-ban, majd a finally-ban, akkor a try-é nem minõsül supressednek, hanem az egyszerûen elvész, mert a finallyban dobottnak le kell futnia mindenképp. Ez rossz kódolási stílus, mert így elvesztünk egy kivételt.


Ha egy fgv több kivételt is throws-ol, akkor azokat elkaphatjuk sorra egymás után, vagy egy mutlicatch-csel is akár.

public void multiCatch() throws SQLException, DateTimeParseException {
	try {
		parseData();
	} catch (SQLException | DateTimeParseException e) {
		System.err.println(e);
		throw e;
	} 
}

Vagy a kettõt eggyel is lehetséges, de ilyenkor mást is elkaphat, mivel generikusabb:

public void rethrowing() throws SQLException, DateTimeParseException {
	try {
		parseData();
	} catch (Exception e) {
		System.err.println(e);
		throw e;
	}
 }

Ha resource lezárásakor excp dobódik, addig nem kerül át a vezérlés a catch-ekhez amíg a többi resource lezárása is meg nem történik. 
Így akár több exp is egymásra halmozódhat a és csak a legutolsó megy át a catch-ekhez. //? nem biztos.
 
 Az erõforrások akkor is lezárásra kerülnek, ha a kód kivételt dobott (még a különbözõ erõforrások esetén is).
 
 Ha a try is dob és a lezárás is, akkor a a try-é elnyomja a lezáráskor keletkezett kivételt.
 
 A try blokk lezárássa után közvetlenül, még a catch-ek bekövetkezte elõtt kezdenek el lentrõl fölfele bezárulni az erõforrások.




































