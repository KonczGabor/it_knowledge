import java.util.concurrent.*;

A thread az oprációs rendszer számára a végrehajtás legkisebb egysége. //Szál
A process az egymással összefüggõ, közös környezetben lévõ threadek csoportja. //Folyamat, program
Közös környezet ahol közvetlenül tudnak ugyanabban a memóriatérben kommunikálni.

Vannak a rendszer által mûködtetett System thread-ek (GC) és a user által definiált user-definied thread-ek, 
illetve a daemon thread-ek, amik leállnak ha a nem damenok le lettek állítva. Ha már csak a GC fut (GC is daemon), akkor kilép.

Minden thread kap valamennyi idõt a thread scheduler-tõl, ha abba nem fér bele akkor lép épetbe a context switch, 
aminek szintén van egy idõköltsége hogy a thread állapotát elmentse és a következõ körben onnan folytatni tudja (save-reload).

A thread-ek fontosságát egy integer alapú thread priority hivatott eldönteni.
Thread.MIN_PRIORITY 1
Thread.NORM_PRIORITY 5
Thread.MAX_PRIORITY 10
----------------------------------------

Thread lifecycle

New Thread (start)
Runnable (run)
Running (sleep)
Waiting (notify, elapsed time)
Dead
----------------------------------------

States

New: Created but not started
Runnable: executing in the JVM
Blocked
Waiting
Timed_waiting
Terminated
----------------------------------------
@FunctionalInterface public interface Runnable {
	void run();
}

Nincs paramétere és nem ad vissza adatot.

//Ezzel szemben a Callable interfész call() metódusa térhet vissza értékkel és dobhat checked exceptiont.
----------------------------------------


Alapvetõen kétféleképpen definiálhatunk egy taskot:

	1: A Thread konstruktornak átadunk egy Rubbanle objectet (Az átadott objektum osztálya implementálja a Runnable interfészt)
		, vagy lambda kifejezést. //Létrejön egy Thread objektum és el kell indítani a start() metódust.
		
	2: A Thread osztályból származtatunk egy sajátot, ami felülírja a run() metódust. Ezen elindítjuk a start() metódust.

public class PrintData implements Runnable {        	//More common
	public void run() {
		for(int i=0; i<3; i++)
			System.out.println("Printing record: "+i);
	}
	public static void main(String[] args) {
		(new Thread(new PrintData())).start();	//el is kell ám indítani!
	}
}

public class ReadInventoryThread extends Thread {	//Less common
	public void run() {
		System.out.println("Printing zoo inventory");
	}
	public static void main(String[] args) {
		(new ReadInventoryThread()).start();	//el is kell ám indítani!
	}
}
----------------------------------------

synchronized keyword

Csak nem-absztrakt pédlány metódsuokra alkalmazható.
Egymásba ágyazható. -deadlock veszély másik hasonló metódus esetén.
A synchronized method cannot be executed simultaneously by more than one thread on the same object.
A run()-t lehet synchronized-dé tenni.
----------------------------------------


join():

Az a thread amelyik meghívja az várakoztatja a saját magát amíg egy másik be nem fejezõdik (i.e. finishes its run() method).
Ilyenkor nincs szükség lock-ra.
----------------------------------------


Polling: az a folyamat amikor bizonyos idõközönként (adott ideig) csekkolgatunk egy adatot. 


public class CheckResults {

	private static int counter = 0;

	public static void main(String[] args) throws InterruptedException {

		new Thread(() -> {
			for(int i=0; i<500; i++) CheckResults.counter++;
		}).start();

		while(CheckResults.counter<100) {
			System.out.println("Not reached yet");
			Thread.sleep(1000); // 1 SECOND
		}

		System.out.println("Reached!");
	}
}
-------------------------------------


Concurrency API biztosítja az Executors factory class-t hogy létrehozhassunk ExecutorService object-eket, amiknek átadhatjuk a thread-jeinket.

Az ExecutorService interfész nem implementálja az AutoClosable-t, szóval nem használhatjuk a try-with-resources-ban. Viszont a finally-ban le lehet zárni:

ExecutorService service = null;
try {
	service = Executors.newSingleThreadExecutor();
	// Add tasks to thread executor
	…
} finally {
	if(service != null) service.shutdown();
}
-------------------------------------

execute() nem, a submit() visszaadja az objektumot, tehát az támogatja a Callable kifejezést.

Az invokeAll() visszatér az összes befejezett task-kal mint Future object-ek listája, az InvokeAny()-nek elég egyet befejezni, a többit cancell-eli.  
-------------------------------------


A Future result vissaztérési értéke null a runnable metódusnak, mivel a runnable() void.


A callable-nek már van visszatérési értéke:

 @FunctionalInterface public interface Callable<V> {
	V call() throws Exception;
}
-------------------------------------


Mind a Runnable run(), mind a Callable call()

Tud dobni unchecked exceptiont,

Megvalósítható lambda kifejezésekkel.
-------------------------------------


A Callable tud dobni checked exceptiont is.

A Callable egy generikus típust ad vissza.
-------------------------------------


scheduleAtFixedRate() amikor az a fontos hogy az adott idõben valami megtörténjen, pl minden reggel megnézzük hogy az állatok egészségügyi állapotát az állatkertben, függetlenül attól hogy egy csekkolás akár 2 óráig is eltarthat.

cheduleAtFixedDelay() Miután feltöltöttük a kaját(lehet h sok idõ) adott idõ elteltével újra hozzákezdünk feltölteni.
-------------------------------------



newCachedThreadPool() = sok rövid életû thread esetén, kötetlen méret, asynchronous hívások esetén.

newFixedThreadPool() = mindet egyszerre futtaja amíg van elég thread a fix méretû poolban, ha elfogyott akkor vár míg fel nem szabadul.

newScheduledThreadPool() = hasonló mint a scheduleAtFixedRate().
-------------------------------------



// kiírja a procik számát: System.out.println(Runtime.getRuntime().availableProcessors());
-------------------------------------


Atomic: egy olyan tulajdonság a mûveltnek mely azt fejezi ki hogy más thread által meg nem szakítható. 
//A ++a nem ilyen, mert egyszer olvas, egyszer "visszaír".
Az atomosság használata során egy kiírás még nem lesz helyes sorrendû többszálas vezérlés esetén, csak elkerüljük hogy többször ugyanaz az adat szerepeljen.

Ha valami szinkronizálva van nem minden esetben szükséges még atomicot is rádobni, úgy se nyúl addig hozzá senki.

A szinkronizáció gyakoraltilag nem más min az adatok konzisztenciájának megõrzése terjesítmény csökkenés árán.
-------------------------------------
Blocking(Queue/Deck)
	vár egy timelimit-ig és ha nem sikerül belerakni, akkor(offer):
		false
	Ha adott ideig nem sikerül kiszedni (poll):
		null
-------------------------------------
CopyOnWrite Collections:


List<Integer> list = new CopyOnWriteArrayList<>(Arrays.asList(4,3,52));

	for(Integer item: list) {
		System.out.print(item+" ");
		list.add(9);
	}

System.out.println();
System.out.println("Size: "+list.size());

When executed as part of a program, this code snippet outputs the following:
4 3 52
Size: 6

Létrehoz egy másolatot az új értékekkel, de az eredetit járja be. 
Így nem jöhet létre végtelen ciklus, illetve ha nem használnánk a CopyOnWrite elõtagot, akkor ConcurrentModificationException dobódna a sima ArrayListen.
Hátránya hogy sok memóriát fogyaszt, mivel minden módosítás során egy új struktúra jön létre.
-------------------------------------


Parallel streams


Létrejhozása:

Stream<Integer> stream = Arrays.asList(1,2,3,4,5,6).stream();
Stream<Integer> parallelStream = stream.parallel();

Vagy:

Stream<Integer> parallelStream2 = Arrays.asList(1,2,3,4,5,6).parallelStream();
--------------------------------------


Arrays.asList(1,2,3,4,5,6)
	.parallelStream()
	.forEachOrdered(s -> System.out.print(s+" "));

//1 2 3 4 5 6 forEachOrdered-del az eredeti sorrendet kapjuk vissza, de sebesség ccsökkenés árán.

--------------------------------------

Scaling is the property that, as we add more resources such as CPUs, the results gradually improve.
Minél több erõforrást vonunk be a teljesítmény javítása érdekében.

Két feladat egyidejû végrejahtása a race condition.

--------------------------------------


Deadlock: két vagy több thread örökre blokkolva lett, egymásra várnak. (rókák) //Elõször valami azért kiíródik (nem megjósolható), exc sem dobódik.

Starvation: Egy thread nem fér hozzá egy erõforráshoz, mert azt más használja.

Livelock: 2 thread megpróbál kijönni deadlockból. A 2 róka odaér a kajához, de nem tudja megenni. Lock én unlcok folyamatok futnak körbe-körbe.

Race condition: Két feladat amiknek egymás után kéne végrehajtódniuk egyszerre hajtódnak végre.
--------------------------------------


Ha több feladat lett egy thread executornak adva mint ahány thread elérhetõ, 
akkor egy belsõ queue-ba kerülnek ezek a feladatok és abban várakoznak az új thread-ekre.
--------------------------------------


A collect() mûveletet csak single thread-en lehet végrehajtani?
--------------------------------------


Itt két Thread object jön létre:
	TestClass tc = new TestClass();			//1
	new Thread( tc.new Runner() ).start();	//2

Thread[] t = new Thread[5];					//Itt nem jön létre egy thread object sem, ez csak egy array, ami 5 Thread object-et tud tárolni.
--------------------------------------


Fork/Join

1,Create a RecursiveAction that subdivides the task into two, then forks one of the tasks and computes another.

2,Subclass RecursiveAction and implement the compute() method that computes the new value but does not return anything. 
--------------------------------------


yield():

Idõszakosan megállítja az adott thread-et és engedi hogy egy másik fusson. Erõsenn platform függõ.

Concurency: Amikor egy feladatot szétbontunk több kisebb darabra és egyszerre futatjuk azokat.

Multitasking: Is a process, handling by the operation system. Time slicing.  

Multithreading:

Parallelism: amikor tényleg egyszerre egymás mellett fut a két folyamat. Nem minden concurrency parallel, mert azok várhatnak egymásra.

A processzorban különbözõ szintû cache.ek vannak (L1,L2,L3-minél kisebb annál gyorsabb és annál beljebb van) 
és ezek között kialakulhat az adatinkonzisztencia.

sleep()-elni csak saját magunkat tudjuk. //Thread.slepp(milisec);

Mi befolyásolhatja a feladatok végrehajtását:
	-Scheduler
	-Processor
	-Threads





































