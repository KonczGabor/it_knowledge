A lambda kifejezés nem más mint egy kódblokk, hasonló mint az anonymus method.

Egy adott metódus paraméternek egy "interfészt" vár, mi viszont az õ egyetlen absztrakt metódusát megvalósító lambda kifejezést adujuk át.

Ez:
a -> a.canHop()

Ugyanaz mint ez:
(Animal a) -> { return a.canHop(); }

paraméter(ek) -> kifejezés teste;  

Ha csak egy paraméter van és nics típus megadva, a "()" elhagyható.
Ha nincs bemenõ paraméter akkor meg kell adni egy  üres "()" párt. Ez nem azonos a fenti egységbe záró "()"-lel. Itt a void-ot hivatott szimbolizálni.

Valid példák:

() -> new Duck()
d -> {return d.quack();}
(Duck d) -> d.quack()
(Animal a, Duck d) -> d.quack() 

Vagy az összes paraméter típusát megadjuk, vagy semelyikét.
------------------


A kifejezés teste:

Ha csak egy utasításunk van, a "{}" elhagyható
Ha csak egy utasításunk van, a "return" elhagyható
Ha csak egy utasításunk van, a ";" elhagyható

Ha "{}" -t írunk és csak egy utsításunk van és vár visszatárási értéket akkor is ki kell tenni a "return" -t, nem csak akkor ha több utasításunk van.
Ha "return"-t írunk kötelezõ a "{}"
Ha "{}" ben minden statement után ki kell tenni a ";"-t

Nem lehet a bemenõ paramétereket újra deklarálni, de újakat lehet.
(a, b) -> { int a = 0; return 5;} // DOES NOT COMPILE

Nem lehet felhasználni nem inicializált változót:
(x,y) -> {int test; return test>0;}		//Fordítási hiba, int nem kapott értéket.

Ez már jó:
(a, b) -> { int c = 0; return 5;}
----------------

Egy egyszerû egyparaméteres, boolean-nal visszatérõ függvény kedvéért nem kell interfészt írni, használhatjuk a beépített Predicate-et is:

import java.util.function.Predicate;

Mely így néz ki:
public interface Predicate<T> {
	public boolean test(T t);
}

Használata:
public class FindMatchingAnimals {
	private static void print(Animal animal, Predicate<Animal> trait) {
	if(trait.test(animal))
		System.out.println(animal);
}

public static void main(String[] args) {
	print(new Animal("fish", false, true), a -> a.canHop());
	print(new Animal("kangaroo", true, false), a -> a.canHop());
	}
}
