Adatbázis: rendezett adatok gyûjteménye.

Alapvetõen kétféle képpen tudunk adatbázist elérni:

	JDBC (Java Database Connectivity Language): Sorokkal és oszlopokkal.

		A négy interfésze:

			Driver: Knows how to get a connection to the database 
					(3rdParty esetén: 1, Put the driver jar in the class path. 2, Retrieve a connection using DriverManager.getConnection.)
					A négyes verziótól már nem kell explicit (direkt) betölteni a Driver class-t.
			Connection: Knows how to communicate with the database (implements a session with the database)

			Statement: Knows how to run the SQL (provides various execute methods to execute queries on the database)

			ResultSet: Knows what was returned by a SELECT query

		//A DriverManager maga konkrét class.	

	JPA (Java Persistence API) mindent objektumokkal, azokon keresztül érünk el, ezt a conceptet hívjuk ORM (object-relational mapping) -nek.
---------------------------------

Alapvetõen vannak a relációs adatbázisok, és azok amik nem táblákba rendezve tárolják adataikat (NoSQL).

DDL (database definition language)

DML (database manipulation language)

CONCUR_UPDATABLE: ResultSet-en keresztül történõ updatelés.
Ha ez engedélyezve van, akkor így kell updatelni RS-en keresztül:
1. Call rs.moveToInsertRow(); first. You can't insert a row without calling this method first. 
2. Use rs.updateXXX methods to update all column values. You must set values for all the columns. 
3. Call rs.insertRow();  
4. Call rs.moveToCurrentRow(); to go back to the row where you were before calling moveToInsertRow.

when you call insertRow without first calling moveToInsertRow -> An SQLException will be thrown.

Az SQL statement executeUpdate egy int-tel tér vissza ami megmondja hogy hány soron történt végrehajtás.

van executeUpdate //delete, set, insert // returns int
van executeQuery // select // returns ResultSet 
és egy általános execute(sql) ami nem int-tel, hanem boolean-nal tér vissza annak megfelelõen hogy querry volt-e. // returns boolean

Egy update a commit után autómatikusan befrissíti az adatbázist, ha kötegelve szeretnénk ezeket végrehajtani, akkor a connectionnál ezt a paramétert kell használni:
con.setAutoCommit(false);
Utána csak akkor hajtódnak végre a kötegek, ha ki is adjuk az utasítást:  con.commit(); 
Ha visszaállítjuk eredetire: con.setAutoCommit(true); -akkor a még el nem küldötteket autómatikusan elküldi.
A JDBC kapcsolat alapból auto-commit mode-ban jön létre.
----------------------------------------------

Reading a ResultSet


Map<Integer, String> idToNameMap = new HashMap<>();

ResultSet rs = stmt.executeQuery("select id, name from species");

while(rs.next()) {		//TYPE_FORWARD_ONLY esetén csak így mehetünk végig. absolute(), relative() (lásd késõbb) nem játszik.
	int id = rs.getInt("id");
	String name = rs.getString("name");
	idToNameMap.put(id, name);
}

System.out.println(idToNameMap); // {1=African Elephant, 2=Zebra}

Ha az sql feltételnek egy rekord sem felel meg, tehát a resultset üres, akkor bele a  while (rs.next()) false-szal tér vissza és nem lesz semmiféle exception

----------------------------------------------

A JDBC nem nullától, hanem egytõl számoz, (pl.: oszlopok) rs.getString(0) will cause an SQLException.
Ez nem mindig bukik ki, pl.: ha nincs record a táblában.

Kétféle képpen nyerhetjük ki az eredményt:
1, rs.getString(int) 	//1-tõl indul nem 0-tól
2, rs.getInt("String")	//Ex, lehet ha a kikeresett "String" oszlop rekordja nem kaszolható Integer-ré
----------------------------------------------

Scrolling ResultSet

	A next()- en kívül mindenhez Scrollable kell, TYPE_SCROLL_INSENSITIVE, vagy TYPE_SCROLL_SENSITIVE
	
Statement stmt = conn.createStatement(
ResultSet.TYPE_SCROLL_INSENSITIVE,	//Bármilyen irányba bejárható (ezt jelenti a SCROLL), de nem fogom látni a változásokat miközben tekerek (INSENSITIVE - azt jelenti hogy nem követi az "underlying data" változásait amíg a ResultSet nyitva van). SENSITIVE esetén látom magáta változásokat is

First paramter:
	ResultSet.TYPE_FORWARD_ONLY
	ResultSet.TYPE_SCROLL_INSENSITIVE
	ResultSet.TYPE_SCROLL_SENSITIVE
	
Second parameter:
	ResultSet.CONCUR_READ_ONLY); 
	ResultSet.CONCUR_UPDATABLE);	//Ezt nem kötelezõ támogatni, resultSet.updateRow()-t meg kell hívni h lássuk az új állapotot.

//A két paraméter felcserélhetõ, mert int íródik be a helyükre, nem lesz fordítási hiba, csak benézés.	
	
Maunálisan lépkedhetünk egy "pointerrel" a sorok közt.
beforeFirst()/afterLast() 	returns void
rs.first()/rs.last()		ugrás az elsõre/utolsóra
rs.previous()/rs.next() 	returns true/false  (és lép/nem lép)

absolute(int): adott sorra ugrik. 0 = beforeFirst. (-1) = utolsó. (-2) = utolsó elõtti

relative(int): az adott pozícióhoz képest mozdul el pozití/negatív irányba. 
	Ha kimennénk a táblából akkor megállunk a peremen és nem dobunk SQLExceptiont, egyszerüen csak elementünk addig amíg lehet.
	Szóval vagy beforeFirst, vagy afterLast pozícióra kerültünk.

Ha nincs támogatva scroll, akkor csak a TYPE_FORWARD_ONLY van érvényben 
és egy azon meghívott rs.previous(); máris SQLException-t eredményez.

Az absolute/realative(adott sor) miding true-t ad vissza ha az adott sor létezik, amire ugrani tudott:
	az absolute(0) => false lesz, mert ott a kurzor nem talál értéket(beforeFirst)
	Ha kimutatunk a sorokból: abolsute(999) az csak szimplán false-szal tér vissza.

----------------------------------------------

Closing Database Resources


public static void main(String[] args) throws SQLException {

	String url = " jdbc:derby:zoo";

	try (Connection conn = DriverManager.getConnection(url);		//A Connection mindig a DriverManager-en keresztül jön létre, közvetlenül nem lehet pédlányosítani.
		Statement stmt = conn.createStatement();
		ResultSet rs = stmt.executeQuery("select name from animal")) { //Az utolsó statementnél nem kötelezo kitenni a ";"-t?
			while (rs.next())
				System.out.println(rs.getString(1));
	}
}
	
Try-with-Resources segítségével zárja be letrõl fölfele haladva az erõforrásokat. 
Elõször: ResultSet 
Másodszor: Statement 
Harmadszor: Connection 


Ha egy statement-et újrafutatunk másik resultset-be, akkor az az elõzõ statement lezárását eredményezi.

Ha lezárok egy Connection-t, akkor vele együtt lezáródik autómatikusan a Statement és a ResultSet.

Ha lezárok egy Statement-et, akkor vele együtt lezáródik autómatikusan a ResultSet.

----------------------------------------------

JDBC URL

jdbc:vendor:database specific name is must, but ip/location/port is optional

	Kötelezõ három elem és a köztük lévõ ":"
	jdbc:magic:127.0.0.1:1234/box		A location és a port közbeékelõdik,de a db vevet megkapjuk, szóval helyes
	jdbc:magic:box						Tökéletes, Jdbc:vendor:dbnév	
	jdbc:magic:@127.0.0.1:1234			Ez nem jó, mert a ":" itt a portot jelenti, tehát a dn-név mint kötelezõ elem elmaradt

----------------------------------------------

Ha a kért statement nem támogatott, pl.:
conn.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);
akkor nem dobódik E, nem áll le a program, egyszerûen a JDBC driver downgrade-eli a kérést és azzal lehet gazdálkodni, ami van.

A Statement automatically starts in auto-commit mode.

----------------------------------------------

A JDBC kód leftuttatásához elengedhetetlen a checked SQLException lekezelése, vagy továbbdobása,
e nélkül a kód nem fog lefordulni.

----------------------------------------------

Áltanános statement futtató:
	boolean stmt.execute(statement)
	Ha a statement query, akkor true-val tér vissza.

	A visszatérés egy szám mely jelzi h hány recordja lett updatelve a táblának:	
		int stmt.executeUpdate()
		
	A visszatérés egy resultset:
		ResultSet stmt.executeQuerry

----------------------------------------------

PreparedStatement jobb teljesítményt nyújt a sima Statement-tel szemben ha ugyanazt a query-t akarjuk futatni csak más paraméterekkel.
Csak önmagában nem nyújt jobb teljesítményt mint a sima Statement.
További elõnye hogy olyan column typokat is támogat mint a CLOB v a BLOB.

----------------------------------------------

Ha egy folyamat sok számítást igényel és az eredményeket egyenként írja be a táblába, hogy rollback esetén ne kelljen újra kiszámítani, a 
	connection.rollback(savePoint);
a használatos.

----------------------------------------------

CallableStatement is that it allows IN/OUT parameters.
A CallableStatement is the only way for a JDBC program to execute stored procedures in the database if the procedure has in and out parameters.

----------------------------------------------

Class.forName() throws a ClassNotFoundException if the driver class is not found.
DriverManager.getConnection() throws a SQLException if the driver class is not found.

----------------------------------------------

A Statement autómatikusan lezárja lezárja a ResultSet-et, ha rajta egy újabb execute-ot hívunk és így SQLException fog dobódni:
	ResultSet rs = stmt.executeQuery("select count(*) from species");
	int num = stmt.executeUpdate("INSERT INTO species VALUES (3, 'Ant', .05)");
	rs.next();
	System.out.println(rs.getInt(1));

----------------------------------------------

Ha a Result set beforeFirst helyén áll(és márpedig midnig ott áll alapból) a kurzor akkor a querry ezzel tér vissza:
	SQLException with the message Invalid cursor state – no current row:
	
----------------------------------------------

//A Derby egy totál másik jar-ban van mint a jdk.

----------------------------------------------

The count(*) function in SQL always returns a number, ha nincs semmi akkor 0-val.