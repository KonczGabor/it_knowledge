Adatbázis: rendezett adatok gyûjteménye.

Alapvetõen kétféle képpen tudunk adatbázist elérni:

	JDBC (Java Database Connectivity Language): Sorokkal és oszlopokkal.

		A négy interfésze:

			Driver: Knows how to get a connection to the database 
					(3rdParty esetén: 1, Put the driver jar in the class path. 2, Retrieve a connection using DriverManager.getConnection.)
					A négyes verziótól már nem kell explicit (direkt) betölteni a Driver class-t.
			Connection: Knows how to communicate with the database (implements a session with the database)

			Statement: Knows how to run the SQL (provides various execute methods to execute queries on the database)

			ResultSet: Knows what was returned by a SELECT query


	JPA (Java Persistence API) mindent objektumokkal, azokokn keresztül érünk el, ezt a conceptet hívjuk ORM (object-relational mapping) -nek.
---------------------------------

Alapvetõen vannak a relációs adatbázisok és azok amik nem táblákba rendezve tárolják adataikat (NoSQL).

DDL (database definition language)

DML (database manipulation language)

CONCUR_UPDATABLE: ResultSet-en keresztül történõ updatelés.
Ha ez engedélyezve van, akkor így kell updatelni RS-en keresztül:
1. Call rs.moveToInsertRow(); first. You can't insert a row without calling this method first. 
2. Use rs.updateXXX methods to update all column values. You must set values for all the columns. 
3. Call rs.insertRow();  
4. Call rs.moveToCurrentRow(); to go back to the row where you were before calling moveToInsertRow.

when you call insertRow without first calling moveToInsertRow -> An SQLException will be thrown.

Az SQL statement executeUpdate egy int-tel tér vissza ami megmondja hogy hány soron történt végrehajtás.

van executeUpdate //delete, set, insert // returns int
van executeQuery // select // returns ResultSet 
és egy általános execute(sql) ami nem int-tel, hanem boolean-nal tér vissza annak megfelelõen hogy querry volt-e. // returns boolean

Egy update a commit után autómatikusan befrissíti az adatbázist, ha kötegelve szeretnénk ezeket végrehajtani, akkor a connectionnál ezt a paramétert kell használni:
con.setAutoCommit(false);
Utána csak akkor hajtódnak végre a kötegek, ha ki is adjuk az utasítást:  con.commit(); 
A JDBC kapcsolat alapból auto-commit mode-ban jön létre.
----------------------------------------------

Reading a ResultSet


Map<Integer, String> idToNameMap = new HashMap<>();

ResultSet rs = stmt.executeQuery("select id, name from species");

while(rs.next()) {		//TYPE_FORWARD_ONLY esetén csak így mehetünk végig. absolute(), relative() (lásd késõbb) nem játszik.
	int id = rs.getInt("id");
	String name = rs.getString("name");
	idToNameMap.put(id, name);
}

System.out.println(idToNameMap); // {1=African Elephant, 2=Zebra}
----------------------------------------------

A JDBC nem nullától, hanem egytõl számoz, (pl.: oszlopok) rs.getString(0) will cause an SQLException.
Ez nem mindig bukik ki, pl.: ha nincs record a táblában.

Kétféle képpen nyerhetjük ki az eredményt:
1, rs.getString(int) 	//1-tõl indul nem 0-tól
2, rs.getInt("String")	//Ex, lehet ha a kikeresett "String" oszlop rekordja nem kaszolható Integer-ré
----------------------------------------------

Scrolling ResultSet

Statement stmt = conn.createStatement(
ResultSet.TYPE_SCROLL_INSENSITIVE,	//Bármilyen irányba bejárható (ezt jelenti a SCROLL), de nem fogom látni a változásokat miközben tekerek (INSENSITIVE - azt jelenti hogy nem követi az "underlying data" változásait amíg a ResultSet nyitva van). SENSITIVE esetén látom magáta változásokat is
ResultSet.CONCUR_READ_ONLY);

Maunálisan lépkedhetünk egy "pointerrel" a sorok közt.
beforeFirst()/afterLast() 	returns void
rs.first()/rs.last()		ugrás az elsõre/utolsóra
rs.previous()/rs.next() 	returns true/false  (és lép/nem lép)

absolute(int): adott sorra ugrik. 0 = beforeFirst. (-1) = utolsó. (-2) = utolsó elõtti

relative(int): az adott pozícióhoz képest mozdul el pozití/negatív irányba. 

Ha nincs támogatva scroll, akkor csak a TYPE_FORWARD_ONLY van érvényben 
és egy azon meghívott rs.previous(); máris SQLException-t eredményez.
----------------------------------------------


Closing Database Resources


public static void main(String[] args) throws SQLException {

	String url = " jdbc:derby:zoo";

	try (Connection conn = DriverManager.getConnection(url);
		Statement stmt = conn.createStatement();
		ResultSet rs = stmt.executeQuery("select name from animal")) { 
			while (rs.next())
				System.out.println(rs.getString(1));
	}
}

Try-with-Resources segítségével zárja be letrõl fölfele haladva az erõforrásokat. 
Elõször: ResultSet 
Másodszor: Statement 
Harmadszor: Connection 


Ha egy statement-et újrafutatunk másik resultset-be, akkor az az elõzõ statement lezárását eredményezi.

Ha lezárok egy Connection-t, akkor vele együtt lezáródik autómatikusan a Statement és a ResultSet.

Ha lezárok egy Statement-et, akkor vele együtt lezáródik autómatikusan a ResultSet.
----------------------------------------------


JDBC URL

jdbc:vendor:database specific name is must, but ip/location/port is optional
----------------------------------------------


Ha a kért statement nem támogatott, pl.:
conn.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);
akkor nem dobódik E, nem áll le a program, egyszerûen a JDBC driver downgrade-eli a kérést és azzal lehet gazdálkodni, ami van.
----------------------------------------------


A JDBC kód leftuttatásához elengehdtetlen a checked SQLException lekezelése, vagy továbbdobása,
e nélkül a kód nem fpg lefordulni.
----------------------------------------------


PreparedStatement jobb teljesítményt nyújt a sima Statement-tel szemben ha ugyanazt a query-t akarjuk futatni csak más paraméterekkel.
Csak önmagában nem nyújt jobb teljesítményt mint a sima Statement.
További elõnye hogy olyan column typokat is támogat mint a CLOB v a BLOB.
----------------------------------------------


Ha egy folyamat sok számítást igényel és az eredményeket egyenként írja be a táblába, hogy rollback esetén ne kelljen újra kiszámítani, a 
	connection.rollback(savePoint);
a használatos.
----------------------------------------------


CallableStatement is that it allows IN/OUT parameters.
A CallableStatement is the only way for a JDBC program to execute stored procedures in the database if the procedure has in and out parameters.
----------------------------------------------