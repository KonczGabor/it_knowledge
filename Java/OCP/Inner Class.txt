Nested class ami egy másik osztályon belül van definiálva:
	Mindegyik amelyik nem static az inner.
	
Nested class-ok használatának elõnyei: 
	helper osztályok közelsége. 
	Ha biztosak vagyunk benne hogy csak az adott helyen akarjuk használni.
	A kód könnyebb olvashatósága.

4 típusa van:

MEMEBER INNER CLASS:

-Bármilyen láthatósága lehet.
-Bármilyen másik osztályból származtatható és megvalósíthat interfészeket.
-Lehet abstract vagy final.
-Nem lehetnek saját statikus tagjai.
-Hozzáférhet a külsõ osztály tagjaihoz (még akkor is ha az private).
-Nem lehet static.
-Példányváltozó szintjén van definiálva.
-A külsõ osztály hozzáférhet a belsõ osztály private tagjaihoz is egy belsõ példányon keresztül.

Gyakorlatilag a külsõ osztály minden példányához külön belsõ osztályok példányai tartoznak.
Ha létre akarom hozni a belsõ osztály objektumát, elõbb a külsõt kell létrehozni.

Ha lefordítunk egy osztályt, ami belsõ osztályt is tartalmaz, akkor két file fog létrajönni, egy sima és egy ilyen elnevezéssel: Outer$Inner.class

belsõ osztálnyak is lehet belsõ osztálya ~ egymásba ágyazhatók.

Az egymásba ágyazott osztályok birtokolhatnak(has) ugyanolyan nevû változókat, ilyenkor a ".this" az épp legaktuálisabb osztályra mutat, a többire annak nevével és a ".this" -szel együtt hivatkozunk. (B.this.x); (A.this.x); Ha elhagyjuk a ".this"-t akkor az adott osztály változója hívódik meg, amiben állunk, vagy ha neki nics olyan, akkor az egyel kijjebb lévõ.

Az osztályokra így hivatkozunk:  //Egy mélységig nem kötelezõ kaidni a pontot(A.B ->B), kettõnél már kell: A.B.C
A a = new A();
A.B b = a.new B();
A.B.C c = b.new C();
c.allTheX(); 


Outer.Inner in = new Outer().new Inner();
------------------------

LOCAL INNER CLASS:

Egy metóduson belül létezik, annak scope-jával jön létre és annak végéig tart.

-A lokális belsõ osztály speciális változata.
-Nincs láthatósági módosítójuk.
-Nem lehetnek static-ok és nem tartalmazhatnak static tagokat.
-Minden külsõ taghoz hozzáférhetnek.
-Nem férhetnek hozzá az õket deklaráló metódus lokális változóihoz, hacsak azok nem (effectively)final-ok.
-------------------------

ANOYMUS INNER CLASS:

-Olyan lokális belsõ osztály, aminek nincs neve.
-Egyazon utasítban deklajáljuk és példányosítjuk a "new" kulcsszóval. Az utasítás vágn a ";" kötelezõ! (Statikus metódusban is lehet õket deklarálni-implementálni.)
-Muszáj hogy származtatva legyenek, vagy megvalósítsanak egy interfészt. Ugyanúgy történik mindekettõ megvalósítása, 
 emiatt a példányosítás során egyértelmûnek kell lennie hogy mit akarunkk megvalósítani. Egy asbztrakt osztályt, vagy egy interfészt? 
 Ez alól csak a java.lang.Object a kivétel.
-Az interfész metódusnak publikusnak kell lenni a megvalósítás során.
-Akkor hasznosak ha egy rövíd implementációt akarunk biztosítani, amit máshol már nem akarunk felhasználni.
Egy basztrakt osztályt megvalósítani és egy interfészt implementálni nem lehet egyszerre egy anonymus inner class-szal. 
-Még paraméter átadáskor is lehetõség van a velük történõ implementációra.

public class AnonInner {
	interface SaleTodayOnly {
		int dollarsOff();
	}
	public int pay() { 
		return admission(5, new SaleTodayOnly() {
			public int dollarsOff() { return 3; }
		});
	}
	public int admission(int basePrice, SaleTodayOnly sale) {return basePrice - sale.dollarsOff();
}}
-------------------------

STATIC NESTED CLASS:

- Nevével ellentétben nem belsõ osztály. 
- Statikus változó szinten van definiálva.
- Lehet példányosítani a külsö osztály példánya nélkül.
- Expilicit kasztolás nélkül nem tud hozzáférni a belsõ osztály tagjaihoz.
- Hozzáférhetünk a külsõ osztályból a privát példánytagjaihoz a statikus osztály példányán keresztül. Nem kell a külsõ osztályból példányt létrehozni.
- Lehetnek privát tagjai.
- Lehet belsõ statikus osztálya.
- Lehet belsõ nem statikus osztálya.
- A külsõ osztály hivatkozhat a static nested class tagjaira.
- Lehet importálni statikusana statikus belsõ osztályt:
	import csomag.Osztaly.StatikusOsztaly;
	import static csomag.Osztaly.StatikusOsztaly;


public class Enclosing {
	static class Nested {
		private int price = 6;
	}
	public static void main(String[] args) {
		Nested nested = new Nested();
	System.out.println(nested.price);
	}
 }



						Member 		Local 		Anonymus	Static

	Láthatóság			all			n/a			n/a			all

	Megvalósíthat		Igen		Igen		Vagy/Vagy	Igen
	interfészt v
	Más osztályt?
	
	Lehet absztrakt?	Igen		Igen		Nem			Igen

	Lehet final?		Igen		Igen		Nem			Igen

	Külsõ osztály		Igen		Igen		Igen		Külsõ osztály
	példánytagjait											példánya szükséges
	eléri?													hogy elérje
	
	Külsõ osztály		Nem			Ha final	Ha final	Nem
	lokális változóit				v e(final)	v e(final)
	eléri?
	
	Lehetnek statikus 	Nem			Nem			Nem			Igen
	metódusai?


Nem statikus belsõ osztálynak lehetnek statikus változói, ha kitesszük a finalt is!	

Statikus metódusban deklarált osztály kilát az összes statikus, fanial és efinal változóra, de példány és automaticra nem.
Nem statikus metódusban deklarált osztály kilát az összes példány, statikus, final, efinal változóra, de automatic-ra nem. 

A külsõ osztály példányváltozóinak láthatósága nem számít a belsõ osztály számára.
A belsõ osztály származtathatja megát a külsõ osztályából, kivéve ha az final. 
Final külsõ osztálynak lehet belsõ osztálya, de az nem számaat bõle.
-------------------------


Ha a TestInner static:		new TestOuter.TestInner();
Ha a TestInner non-static: 	new TestOuter().new TestInner();  	//vagy: TestOuter to = new TestOuter(); 
																		to.new TestInner();
																		

	
