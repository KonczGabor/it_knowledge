A path String alapú 
File parent = new File("/home/smith");

System.out.println(System.getProperty("file.separator"));  	//"\" -windows
System.out.println(java.io.File.separator);			//"\" -windows
System.getProperty("line.separator");

delete() mehet file-ra vagy  directory-ra, de a mappának üresnek kell lennie.

mkdirs() nem csak a mappát hozza létre hanem az útvonalat is, ha eddig az nem volt.
mkdir() can only create the last component of a path. It cannot create a directory structure. For that you must use mkdirs().

Hogy ne kelljen mindig ide-oda fordulni a program és sa filerendszer között a Buffered felhalmozza és egyszerre hajtja végrea dolgokat.
--------------------------------


Beépített stream-ek:
	System.in
	System.err
	System.out
--------------------------------


A stream osztályok i/o -ra bináris és byte típusú adatoka használnak.

A reader és writer osztályok i/o -ra character és String típusú adatokat használnak.

A PrintWriter és PrintStream osztályoknak nincsenek bemenõ megfelelõik.
--------------------------------


character stream-ek (Reader/Writer) elõnyei a byte (InputStream/OutputStream) alapúakkal szemben:
-Kényelmesebb szintaxis amikor Stringekkel dolgozunk.
-Autómatikus karakterkódolás
---------------------------------


low-level stream közvetlenül férnek hozzá a nyers adatokhoz, míg a high-level streamek a low-lewelekre épülnek,
Wrappingolják konstruktoraikkal õket, filterezik.

try (BufferedReader bufferedReader = new BufferedReader(new FileReader("zoo-data.txt"))) 
	{
		System.out.println(bufferedReader.readLine());
	}
-------------------------------------


high-level streameket is lehet wrappolni: 	//(, még egy ugyanolyan típusú is wrappolhat egy ugyanolyat)

try (ObjectInputStream objectStream = new ObjectInputStream(
	new BufferedInputStream(
		new FileInputStream("zoo-data.txt"))))
	{
		System.out.println(objectStream.readObject());
	}
-------------------------------------


Flushing

Vagy bizonyos idõ eltelt után, vagy ha már megtelt a temporary cache, a memóriából kiírjuk az adatokat a filerendszerre.
A close() autómatikusan meghívja.
-------------------------------------


mark() -kal megjelölhetjük hogy hová akarunk visszatérni, a stream mely eleméhez a reset() után.	//a mark egész szám 1 tõl indul ás inclusive.
//annyival megyünk elõre (azt is beleértve) amennyit megmarkoltunk. (~puffer)
1234  1-es read után mark()-olva a kettest fogjuk beolvasni ha reset()-elünk.
-------------------------------------


Memóriabeli objektum kiírása a filrendszerbe a serialization, ellentette (elõállítani az objektumot nyers adatokból) a deserialziation.
Bármilyen osztályt, asbsztraktot, konkrétot, vagy finalt-t lehet serializálni.
Process heavy osztályokat nehéz szérializálni.

Nem kell mást teni, mint implementálni a Serializable interfészt (nem kell megvalósítani semmilyen metódust), 
illetve az osztály beágyazottt osztályainak is meg kell ugyenzt tenni, különben NotSerializableException lép fel.
Ha valamit nem szeretnénk ebbe belefoglalni, akkor az objekt kapja meg a transient kulcszót.

A static változók nem mentõdnek le, mert hát azok nem az adott objektumhoz tartoznak. Ha azt szeretnénk h õk is kerüljekenk kimentésre
akkor egy külön példányváltozóba tároljuk le az épp aktuális értéküket. 

Ha objektumokat deserializálunk akkor nem a (-1)-et, hanem az EOFException -t kell használni.
Fontos még egy if instanceof és utána kasztolás is.

Deserialization során nem futnak le a statikus inicializáló blokkok, sem a konstruktor.
A statikus osztálytagok az épp aktuális értéket kapják meg, a példánytagok az adotttípus default-ját.
A szerailizált osztály elsõ nem szerializált szülõjét hívja meg, annak is az argumentum nélküli konstruktorát.

Az ObjectInputStream és az ObjectOutputStream használata szükséges.
--------------------------------------

A java.io.Console egy singleton. Ahol le van tiltva ott null lesz a return és nem lesz ex.

        Console c = System.console(); 
        String line = c.readLine("Please enter your name:"); 
        System.out.println("Hello, "+line); 
--------------------------------------

Többféle képpen is tudunk kiírni konzolra:

console.writer().println("");
console.format("");
console.printf("");

nincs: 
print('')
println("");
out();
----------------------------------------


a readPassword nem -Stringer ad vissza, hanem char[] -t; Azért h ne maradjon meg a String poolban amíg a gc le nem fut (biztonsági okok).
boolean match = Arrays.equals(password,verify);
Array.fill(password,'x')
Array.fill(verify,'x')
----------------------------------------


java.io.File -ban nincs mv(), move(), copy parancs, helyette renameTo(), mkdir(), mkdirs()
parancs használatos, másoláshoz pedig be kell olvasni a filet stream()-mel.

to create new file:

new File("c:\\book\\java"); 	//escape miatt
new File("c:/book/java");
-----------------------------------------


mark() utasítás elõtt a Stream-en célszerû megnézni h engedélyezett-e, különben meg nem jósolható lesz az eredmény.
A mark() visszavonható a reset() -tel és akkor az elejére ugrik a "pointer".
-----------------------------------------


Ha nincs még olyan fileunk amibe írni szeretnénk, akkor készít egyet és nem dob Et.
Ha már van, akkor azt felülírja, ha azt seretnénk h csak hozzírjon: public FileWriter(String fileName,  boolean append)

getParent() returns a String and getParentFile() returns a File object.
-----------------------------------------


Exceptions:

java.nio.file.InvalidPathException : test.txt
is thrown when the argument passed while creating Path object is invalid. For example, "c:c:test.txt".

java.io.FileNotFoundException
may be thrown by FileInputStream, FileOutputStream, and RandomAccessFile constructors if the file by the given name does not exist.

java.nio.file.NoSuchFileException: test.txt
will be thrown when the program tries to create a BufferedReader to read the file specified by the Path object.

copy("c:\\temp\\test1.txt", "c:\\temp\\test2.txt"); ha nem létezik a test2.txt, akkor nem dob hibát, hanem megcsinálja és belemásolja.

You can always create a File object whether or not an actual file or directory by that name exists.
-----------------------------------------


file.
	létzeik:
		mkdir()
		mkdirs()
		renameTo()
		
	nem létezik:
		mv()
		createDirectory()
		move()
		copy()	//helyette stream.mel be kell olvasni, majd kiiírni a file-t.


















































