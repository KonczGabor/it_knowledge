java.util.stream

Funkcionális programozás. Csak megmondom h mit szeretnék, ahelyett hogy procedúrálisan lépésenként kiadnám az utasításokat.

----------------------

Map-en nem lehet stream-et hívni!:
	

	
----------------------
	
A Stream adatok sorozata. 
A Streamek segítségével lehetové válik h Java collection-ökön használjuk a funkcionális programozás lehetoségeit (map(), reduce, etc..)
Rövidebb, tömörebb, tisztább kódot eredményez, mely olvashatóbbá teszi a kódot.

Stream pipeline: a mûveletek(stream operations) amik lefutnak a stream-en azért hogy elõálljon egy result.

A streamek paraméterekként kaphatnak lambdákat, methodreference-eket.

----------------------

Ha egy stream-et már használtunk, utána már nem használhatjuk újból, IllegalStateException-t fogunk kapni.
	 List<String> myList = new LinkedList<>();
        myList.add("Archi");
        myList.add("X-men");

        Stream<String> myStream = myList.stream();
        myStream.forEach(System.out::println);
        myStream.forEach(System.out::println);
		
		
	Ha a steamünk egy listából jött létre, akkor arra nincs hatással utólag:
		List<String> myList = new LinkedList<>();
        myList.add("Archi");
        myList.add("X-men");
        myList.add("San Francisco");

        long c = myList.stream().filter(x->x.length()> 10).count();
        System.out.println(myList.size() + " " + c);		//3 1
		
----------------------

Stream pipeline részei:

	1,Source					//Formálisan kötelezo
	2,Intermediate operations	//Nulla vagy több
	3,Terminal operations		//Formálisan kötelezo
		Ha nincs megadva terminal operation akkor a stream csak viszatér öngamával, de nem hajtódik végre. 
		streams are lazily evaluated. This means that the stream isn’t actually created until the point when they needed.

----------------------

Creating Streams:

	Közvetlen Stream-bol:

		Stream<String> empty = Stream.empty(); // count = 0
		
		Stream<Integer> singleElement = Stream.of(1); // count = 1
		
		Stream<Integer> fromArray = Stream.of(1, 2, 3); // count = 2
		
	Array-ból:
	
		int[] myIntArray = {1,2,3};							//Array -ból
		IntStream myIntStream = Arrays.stream(myIntArray);	//Stream<Integer> nem fordul, mert ezek intek, nem Integer-ek.
		
		Integer[] myIntegerArray = {1,2,3};
		Stream<Integer> myIntegerStream = Arrays.stream(myIntegerArray);
		
	List-bol
	
		List<String> list = Arrays.asList("a", "b", "c");
		Stream<String> streamFromList = list.stream();
		
	Parallel:
	
		Stream<String> parallelStreamFromList = list.parallelStream();
	
	Creating infinite Streams:
	
		Stream<Double> randoms = Stream.generate(Math::random);
		Stream<Integer> oddNumbers = Stream.iterate(1, n -> n + 2);		
			//Az elso itaráció az eredeti "nyitó" elemet adja visssza.
	
----------------------

Intermediate Operations:
	A terminal operation-ökkel ellentétben könnyen tudnak goldozoni infinite stream-ekkel is, hiszen elég csak az adott elemre fókuszálniuk:
	
	filter(Predicate):
		Az adott kiritériumnak megfelelo elemeket engedi csak át, a többit "kidobja"
		
		Negálni nem lehet a metódus referenciát, muszáj lamdát használni a tagadáshoz: 
			.filter(x->!x.isEmpty())
		
	distinct():
		A többször elofurduló elemek gyakoriságát 1-re csökkenti.
			Stream<String> s = Stream.of("duck", "duck", "duck", "goose");
			s.distinct().forEach(System.out::print); // duckgoose
			
	skip():
		kihagy(paraméter) számú elemet.
			Stream<Integer> s = Stream.iterate(1, n -> n + 1);	//végtelenbe és tovább
			s.skip(5).forEach(System.out::print); // 678.....

	limit():
		maximum ennyi darabszámú elemet ír ki(paraméter).
			Stream<Integer> s = Stream.iterate(1, n -> n + 1);	//végtelenbe és tovább
			s.limit(5).forEach(System.out::print); // 12345
			
	map():
		SEMMI KÖZE A Map Interface-HEZ!
		object bol -> object be konvertál. 
		Nem egy adott elemmel tér vissza, hanem az új elemek stream-ével.
		Nem muszáj h az elemek típust váltsanak, lehet az adott elem kétszerese, de válthatnak is:
			Stream<String> s = Stream.of("monkey", "gorilla", "bonobo");
			s.map(String::length).forEach(System.out::print); // 676
		
	flatMap():
		Egyetlen streambe rendezi az adatszerkezetet, nem rekurzív, csak egyszeres mélységben járja be a collection-t.
			List<String> zero = Arrays.asList();
			List<String> one = Arrays.asList("Bonobo");
			List<String> two = Arrays.asList("Mama Gorilla", "Baby Gorilla");
			Stream<List<String>> animals = Stream.of(zero, one, two);
			animals.flatMap(l -> l.stream()).forEach(System.out::println);					// x -> x fordítási hiba lenne
			//paraméterként egy functiont vár, ami egy elembõl egy stream-et képez: l->l.stream()
			
			Több különbözo típusú collection-t is ki tud vasalni, az üreseket kihagyja:
				Set<String> mySet = new HashSet<>();
				mySet.add("setElem");
				List<String> myList = Collections.emptyList();
				Deque myDeque = new ArrayDeque();
				myDeque.push(123);
				Stream.of(mySet, myList, myDeque).flatMap(x -> x.stream()).forEach(System.out::print);	//setElem123

			PrimitívStreamet is elo lehet állítani vele Streambol:
				IntStream myPrimitiveInts = IntStream.of(1,2,3);
				IntStream myPrimitiveInts2 = IntStream.of(4,5,6);
				IntStream result = Stream.of(myPrimitiveInts,myPrimitiveInts2).flatMapToInt(x->x);	//Itt még nem termináljuk a stream-et, tehát felhasználhatjuk késobb.
				result.forEach(System.out::print);	//123456
			
	sorted():
		Natural ordering szerint rendez, de custom Comparator segítségével túlterhelheto.
			Stream<String> s = Stream.of("brown bear-", "grizzly-");
			s.sorted(Comparator.reverseOrder())	.forEach(System.out::print); // grizzly-brown bear-		
			
			//A reverseOrder()-t a Comparator-on hívjuk, nem a stream-en, és a reversed() is egy adott comparator-on hívódik, az se stream-en:
				Stream<Integer> myIntegerstream = Stream.of(1,2,3);
				Comparator<Integer> myComparator = (x,y) -> x-y;	
				List<Integer> result = myIntegerstream.sorted(myComparator.reversed()).collect(Collectors.toList());			//result = [3, 2, 1] , ha nem reverselnénk. akkor egynes lenne a sorrend.
				//Használható a sorted(Comparator.reverseOrder()) , a sorted(Comparator::reverseOrder) szintaktikailag hibás.
				
			Infinite stream esetén hang.
				
			
	peak():
		A Queue-s peek()-kel ellentétben nem csak egy elemet néz meg, hanem minden rajta átmenovel meghív egy consumer-t.
		Fontos h segítségével ne módosítsuk a stream-et, mert azzal pont az ellenkezojét érjük el, megfigyelés helyett belekontárkodunk.
		
			Helyes használat:
				List<Integer> numbers = new ArrayList<>();
				List<Character> letters = new ArrayList<>();
				numbers.add(1);
				letters.add('a');
				
				StringBuilder builder = new StringBuilder();
				Stream<List<?>> good = Stream.of(numbers, letters);
				good.peek(l -> builder.append(l)).map(List::size).forEach(System.out::print); // 11
				System.out.println(builder); // [1][a]
				
			Helytelen használat:
				Stream<List<?>> bad = Stream.of(numbers, letters);
				bad.peek(l -> l.remove(0)).map(List::size).forEach(System.out::print); // 00
	
		
	boxed():
		Ha primitív értékeket szeretnéni a wrapper osztályaikba boxolni és visszatérni egy Stream<T>-mel:
					  
			Az eredeti, "hosszú" megoldás:
			List<Integer> evenInts1 = IntStream.rangeClosed(1, 10)
				.filter(i -> i % 2 == 0)
				.mapToObj(i->(Integer)i)					//A sima map(i->(Integer)i) nem mûködik			
				.collect(Collectors.toList());
			
			Az elegáns:		
			List<Integer> evenInts = IntStream.rangeClosed(1, 10)
				.filter(i -> i % 2 == 0)
				.boxed()
				.collect(Collectors.toList());			

----------------------

Terminal Operations:

	Reduction:
		esetén végig kell nézni az egész stream-et hogy generáljunk egyetlen value-t.
				
		Amik redukálnak:
		
			collect():
				Segítségével ki tudunk nyerni adatokat új formába gyujtve.
				Elég bonyolúlt a szerkezete mivel három részbol áll:
					Supplier:
						Létrehozza a Collection-t amiben le fogjuk tárolni az adatokat.
					
					BiConsumer:
						Belepakolja az adatokat a Collection-be.
										
					BiConsumer:
						Ez a furi, mert két Collection-t merge-el össze, párhuzamos feldolgozásnál hasznos. Fog két collection-t és össze mergeli oket.
							Stream<String> stream = Stream.of("w", "o", "l", "f");
							TreeSet<String> set = stream.collect(TreeSet::new, TreeSet::add, TreeSet::addAll);
							System.out.println(set); // [f, l, o, w]
							
						Van egy rövidebb válzotata, amikor ezt a szignatúrát leegyszerusíthetjük egy collector segítségével:
							Stream<String> myStream = Stream.of("w","o","l","f");
							TreeSet<String> myTreeSet = myStream.collect(Collectors.toCollection(TreeSet::new));		//Vagy Set<String> set = stream.collect(Collectors.toSet());
							System.out.println("myTreeSet = " + myTreeSet);				//myTreeSet = [f, l, o, w]
							
														
			count():	//mindig long-gal tér vissza.
				Megmondja ez adott stream elemszámát. Infinite stream esetén hang.
				Stream<String> s = Stream.of("monkey", "gorilla", "bonobo");
				System.out.println(s.count()); // 3
				
			min()/max():
				Infinite stream esetén hang.
				Fontos h Optional-lel tér vissza, mert lehet h nincs a stream-ben elem, vagy mind ugyanolyan.
				Primitív stream esetén nincs szükség Comparator-ra, Object Stream-ek esetén kötelezo.
					myStream.min(Integer::compareTo)
					myStream.max(Integer::compareTo)
					//Erdekes hogy a
						Stream<Integer> myStream = Stream.of(4, 55, 6, 78);
						a System.out.println(myStream.min((a, b) -> a < b ? a : b));Optional[78]-cal tér vissza, a jó megoldás:
							System.out.println(myStream.min((a, b) -> a-b));	//Optional[4]
							System.out.println(myStream.min((a, b) -> b-a));	//Optional[78]
				
			reduce:
				Az egész stream-et egyetlen elemmé redukálja:
					Stream<Integer> stream = Stream.of(1, 2, 3);
					Integer sum = stream.reduce(0, (a, b) -> a + b);		//A 0 az identity, ahonnan indulunk, a második paraméter az accumulator.
					System.out.println("sum = " + sum);
					
					Overloadolva van, ha nem adunk meg identity-t, és nem áll rendelkezésre elem, akkor Optional.empty-t ad vissza.
					Ha a stream egy elemü akkor azt adja vissza.
					Ha van legalább két elem, akkor lefut az accumulator.
					
						BinaryOperator<Integer> sum = (x,y) -> x+y;
					
						Stream<Integer> empty = Stream.empty();			
						Stream<Integer> oneElement = Stream.of(1);
						Stream<Integer> multipleElement = Stream.of(1,2,3,4,5);
																					//a reduce-szal véget ért a stream, az ifPresent() már az Optional-ön van hívva.
						empty.reduce(sum).ifPresent(System.out::println);			//nem ír ki semmit, ha ez lett volna  System.out.println(empty.reduce(sum)); => Optional.empty
						oneElement.reduce(sum).ifPresent(System.out::println);		//1, 				ha ez lett volna  System.out.println(oneElement.reduce(sum)); => Optional[1]
						multipleElement.reduce(sum).ifPresent(System.out::println);	//15
						
					Ha nem adunk meg identity-t akkor muszáj h a referencia Optional legyen:
						Primitív stream esetén:
							OptionalInt result = myIntStream.reduce((x,y)->x+y);
						
						Obj stream esetén:
							Optional<Integer> result = myIntegerStream.reduce((x,y) -> x+y);
							
					Ha adunk meg identity-t akkor nem használhatunk Optional referenciát, hisz konkrétan az identity típusa fog eloállni:
						Integer sum = Stream.of(1,2,3).reduce(0,(x,y)->x+y);	// 0 ==> indukálja az Integer-t
					
			
		Amik nem redukálnak:
			Néhány azért nem reduction, mert nem nézi végig az egészet (megbukik már az elején),
			vagy nem tér vissza semmivel.
		
			boolean-nal tér vissza (hang-elnek infinite stream esetén):				
		
				boolean allMatch(Predicate <? super T> predicate):
					Ha már az elso elem nem felel meg false-szal tér vissza, Infinite stream esetén hang, mert nem tudja h az utolsó is egyezni fog-e.
				
				boolean anyMatch(Predicate <? super T> predicate):
					Amint talál a feltételeknek megfelelo eleme terminál, infinite esetén addig megy amíg nem talál a Predicate-nek megfelelot.
				
				boolean noneMatch(Predicate <? super T> predicate)
					Ezt ellenorzi h az összes adat közül semelyik semelyikre sem igaz a feltétel. Infinite stream esetén hang, mert nem lehet biztos benne h az utolsó elem-is nem megfelelo.
					
			Optional-lel tér vissza:
			
				Optional<T> findAny():
					
					Nagyon hasznos parallel streamek esetén mert gyorsan ad megoldást, nem determinisztikus.					
					Attól mert még a stream nem parallel attól még nem biztos h a findAny() az elso paramrétert fogja visszadni.
						IntStream.range(1,1000).findAny().ifPresent(System.out::println); //Nekem mindong 1-et adott, de a vizsgafeladat szerint bármi lehet annak ellenére h nem parallel.
					
				Optional<T> findFirst():
				
					Deterministikusan minidig az elso találatot adja, még parallel stream-ek esetén is:
					
			Nincs visszatérési értéke: 
			
				void forEach(Consumer<? super T> action):
					A stream minden elemét bedobja egy consumerbe, de nem determinisztikus sorrendben.					
					Infinite stream esetén hang.
					
					static List<Integer> myStaticIntegerList = new LinkedList<>();
					
					static void putInTheList(Integer i) {
						myStaticIntegerList.add(i);
					}
					
					String[] strings = { "1", "2", "3" };
					
					Arrays.stream(strings).map(x -> Integer.valueOf(x)).forEach(MyClass::putInTheList);
					//A egy Listen is meg lehet hívni a forEach()-t de ez nem ugyan az a foreEach(), mint ami a Streameken értelmezve van. Szintén egy Consumert vár.
						List<Integer> myInts = Arrays.asList(1,2,3,4,5);
						myInts.forEach(System.out::print);
				
			
	findFirst vs findAny:
	
			   Map<Integer, String> myMap = new HashMap<>();
				myMap.put(1,"egy");
				myMap.put(2,"egy");
				myMap.put(3,"egy");
				myMap.put(4,"egy");
				myMap.put(5,"egy");

				Optional<Map.Entry<Integer, String>> myOptionalMalp = myMap.entrySet().parallelStream().filter(x -> x.getValue() == "egy").findAny();
				System.out.println("myOptionalMap = " + myOptionalMap);
				
				Nem determinisztikusan össze-vissza adogatja a találatokat, míg findFirst() esetén az eredény minidg: myOptionalMap = Optional[1=egy] lenne.


----------------------

reduced:
	Ha ez eredeti számosságát csökkenti úgy hogy valójában annak minden elémét bejárja. 
	Ha csak visszakpunk egy értéket(findAny) az még nem minõsûl reduce()-nak.

----------------------

destructive:
	Destruktívnak nevezzük azt a termináló operátort mely, használata után érvényteleníti a stream-et.
	A count() nem destruktív.

----------------------
	
	Primitív stream-ek:
	
		Eddig minden Streamünk objektumokat tárolt, ha kellett autoboxolt Wrapper osztályra. Viszont számos hasznos fgv csak primitive stream-eken hívható:
					
			sum():
				Stream<Integer> myStream = Stream.of(1, 2, 3);
				System.out.println(myStream.mapToInt(x->x).sum());			// 6
				Stream<Integer> myEmptyStream = Stream.of();   
				System.out.println(myEmptyStream.mapToInt(x -> x).sum());	// 0
			
			average():											//Mindig OptionalDouble a visszatérés
				IntStream intStream = IntStream.of(1, 2, 3);
				OptionalDouble avg = intStream.average(); 		//Üres stream esetén: OptionalDouble.empty
				
			range():
				excluding:	//Az alap eset
					IntStream.range(1, 6).forEach(System.out::print);		//12345
				including:
					IntStream.rangeClosed(1, 6).forEach(System.out::print);	//123456

		Creating Primitve Streams:
			
			Három fo típusa van:
				
				DoubleStream:
					double 
					float
									
				IntStream:
					int
					short
					byte
					char
				
				LongStream:
					long
				
		Primitív stream-ek Optional visszatéréséi értéke nem Optional, hanem Optional+az adott primitive stream: //pl.: OptionalDouble.empty
			OptionalDouble avg = Intstream.rangeClosed(1,10).average;
			Csekk: avg.ifPresent(System.out::println);
			double myDoubleAvg = avg.getAsDouble();
				//Ha nincsenek elemek és így OptionalDoule.empty-val térne vissza és azon hívunk getAsDouble()-t akkor elszáll: NoSuchElementException -nal:
					DoubleStream.empty().average().getAsDouble();
					
			
		Statistic:

			private int range(IntStream ints){
				IntSummaryStatistics stat = ints.summaryStatistics();
				if(stat.getCount() == 0) throw new RuntimeException("Nincs elég elem");
				return stat.getMax()-stat.getMin();		//SummaryStatistics segítségével többször is meg tudunk hívni terminátorokat(?)
			}	

----------------------


Streamek és az alattuk lévo adatok kapcsolata:
	
	Mivel a Stream-ek lazy módon jönnek létre:
		
		List<String> cats = new ArrayList<>();
		cats.add("Annie");
		cats.add("Ripley");
		Stream<String> stream = cats.stream();
		cats.add("KC");
		System.out.println(stream.count());		// 3
		
	Ezért a stream termináló operátorának meghívásakor az alatta lévo collection aktuális állapota fog kiértékelodni.

-----------------------------

Exception handling:

	A checked ecxeption-ök et a streamekben is le kell kezelni, ennek két féle módja van:
		
		Adott:
			 static List<String> makeTrouble() throws IOException {
				throw new IOException();							//nem kell return ha dobunk bármilyen exception-t (Checked/Unchecked)
			}
	
		A csúnya az, amikor elveszítjük a funkcionalizmust mert be kell ágyazni egy Unchecked ecxeption átalakításba:
			Supplier<List<String>> createStringList = () ->{
				try{
					return makeTrouble();
				}
				catch(IOException e){
					throw new RuntimeException(e);
				}
			};				//Inicializálásnál ki kell tenni a ";"-t.

		A másik, egy fokkal szebb, ekkor egy máisk metódusba szervezzük, ami ott helyben burkol:
			static List<String> createSafeStringList(){
				try{
					return makeTrouble();
				}
				catch(IOException e){
					throw new RuntimeException(e);
				}
			}
			
			Supplier<List<String>> safeStringListSupplier = MyClass::createSafeStringList;
	

-----------------------------

Collectors:

	Segítségével a a stream-et hagyományos collection-né tudjuk transzformálni. Gyakorlatilag a stream végén kieso elemeket belepakoljuk egy új collection-be.
	
	Basic collectors:
	
		joining():	//Itt nem Collection be válogatunk le hanem egy adott értéket állítunk elo.
			Stream<String> myString = Stream.of("Lions", "Tigers", "Bears");
			String result = myString.collect(Collectors.joining(", "));			//A paraméter itt egy delimeter, ami az elemek közé beszúrásra kerül. 
			System.out.println(result);		//Lions, Tigers, Bears
			
		
	Collection to List:
		SStream<String> ohMy = Stream.of("lions", "tigers", "bears");
        List<String> myList = ohMy.collect(Collectors.toList());
		//Nincs olyan metódus h Collectors.toArrayList();
			
			
	Collecting to Maps:
	
		Stream<String> ohMy = Stream.of("lions", "tigers", "bears");
		Map<String, Integer> map = ohMy.collect(
		Collectors.toMap(s -> s, String::length));					//A key az adott elem lesz, az érték pedig az elem hossza.
		System.out.println(map); // {lions=5, bears=5, tigers=6}
		

	Tútlterhelt collectors:
	
		toMap:
		
			Stream<String> myString = Stream.of("Lions", "Tigers", "Bears");
			
			Négy részbol áll:
				Key Mapper: Kulcsot kell generálnia,
				Value Mapper: A value-kat állítja be,
				MergeFunction: Megadja h megegyezo Key-ek esetén mi történjen a value-kkal,		//Ha nem adunk meg ilyet, akkor futás idõben megegyezõ kulcsok esetén java.lang.IllegalStateException fog dobódni.
				MapSupplier: Ebbe a Collection-be pakolja bele az eredményt.	
			
			TreeMap<Integer, String> myTreeMap = myString.collect(Collectors.toMap(String::length, value -> value, (value1, value2) -> value1 + "," + value2, TreeMap::new));	
			System.out.println(myTreeMap);	//{5=Lions,Bears, 6=Tigers}
						
		
		groupingBy():
			Alapból Map-et ad vissza, de overloadolt változatban egy supplier-rel személyre szabhatjuk a visszatérés típusát.
			Stream<String> ohMy = Stream.of("lions", "tigers", "bears");
			Map<Integer, List<String>> map = ohMy.collect(
			Collectors.groupingBy(String::length));
			System.out.println(map); // {5=[lions, bears], 6=[tigers]}
			
				Ha más típusú Collection-be szeretnénk leválogatni a value-kat:
					
					Map<Integer, Set<String>> map = ohMy.collect(
					Collectors.groupingBy(String::length, Collectors.toSet()));		//Set-be akarjuk tenni a value-kat
					System.out.println(map); // {5=[lions, bears], 6=[tigers]}
					
				Ha konkrétan más típusú adatszerkezettel szeretnénk visszatérni:
				
					TreeMap<Integer, Set<String>> map = ohMy.collect(
					Collectors.groupingBy(String::length, TreeMap::new, Collectors.toSet()));	//TreeMap-pel szeretnénk visszatérni, a value-k set-ek.
					System.out.println(map); // {5=[lions, bears], 6=[tigers]}
					
				Kulcs szerinti elofordulások száma:
				
					Stream<String> ohMy = Stream.of("lions", "tigers", "bears");
					Map<Integer, Long> map = ohMy.collect(Collectors.groupingBy(
					String::length, Collectors.counting()));
					System.out.println(map); // {5=2, 6=1}
					
				Kulcs szerinti összesítések:
				
					summingDouble(ToDoubleFunction f)
					summingInt(ToIntFunction f)
					summingLong(ToLongFunction f)
					
						
					
				Üres stream esetén:
					{false=[], true=[]}
				
		partitioningBy():
			Hasonlóan muködik mint a groupping, kivéve hogy a kulcs mindig true/false
			
			Map<Boolean, List<String>> map = ohMy.collect(
			Collectors.partitioningBy(s -> s.length() <= 5));			//Egy Predicate-et vár.
			System.out.println(map); // {false=[tigers], true=[lions, bears]}
			
			Üres stream esetén:
				{}
				
-----------------------------					
					
	Stream<String> s = Stream.empty();
	Stream<String> s2 = Stream.empty();
	Map<Boolean, List<String>> p = s.collect(
	Collectors.partitioningBy(b -> b.startsWith("c")));
	Map<Boolean, List<String>> g = s2.collect(
	Collectors.groupingBy(b -> b.startsWith("c")));
	System.out.println(p + " " + g);		//{false=[], true=[]} {}
	The partitioningBy() operation always returns a map with two Boolean keys, even if there are no corresponding values. 
	By contrast, groupingBy() returns only keys that are actually needed.	
		
		
-----------------------------		
		
.findany() csak így paraméter nélkül: visszadja az elsõ elemet, ami papíron bármi lehet, nem jelenthetjük ki h az adott collection elso helyen álló eleme, de általában az. 
Ha parallelStream()-en hívjuk meg, mert akkor bármivel visszatérhet. 
A findFirst() a parallel streamek esetén kötött sorrendiséget eszközöl ki, tehát bukjuk a párhutamos feldolgozás nyújtotta sebességet.
A skip(),limit(),findfirst() utasítások lassítják a párhuzamos feldolgozást, viszont újra szinkronba hozzák õket, így az eredmény rendezett lista esetén olyan, mintha nem is lenne parallel.

Arrays.asList(1,2,3,4,5,6).stream().unordered().parallel(); -unordered: megnöveli a teljesítményt.

-----------------------------

Fork-Join során nem grantált hogy minden résztvevõ egyforma méretü feladatot kap, a lényeg csak az hogy a nagy feladat fel legyen osztva.

---------------------------


There is no Collectors.joining method that takes any functional interface as argument. 

